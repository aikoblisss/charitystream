<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Charity Stream - Watch Ads for Good Causes</title>
  
  <!-- Inter font -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
  
  <!-- Video.js CSS -->
  <link href="https://vjs.zencdn.net/8.10.0/video-js.css" rel="stylesheet" />
  
  <style>
    /* Reset and base styles */
    *, *::before, *::after {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    html, body {
      height: 100%;
    }

    body {
      font-family: 'Inter', ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      font-feature-settings: 'liga' 1, 'calt' 1, 'tnum' 1;
      background-color: white;
      color: #111827;
      line-height: 1.5;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      display: flex;
      flex-direction: column;
    }

    /* Brand colors */
    :root {
      --brand-500: #2F7D31;
      --brand-600: #2F7D31;
      --brand-700: #276629;
      --fora-bg: #E9FFE9;
      --gray-50: #f9fafb;
      --gray-200: #e5e7eb;
      --gray-600: #4b5563;
      --gray-700: #374151;
      --gray-800: #1f2937;
      
      /* Skeleton loading colors */
      --skeleton-bg: #f3f4f6;
      --skeleton-shine: #e5e7eb;
      --gray-900: #111827;
    }

    /* Skeleton Loading Styles */
    .skeleton {
      background: linear-gradient(90deg, var(--skeleton-bg) 25%, var(--skeleton-shine) 50%, var(--skeleton-bg) 75%);
      background-size: 200% 100%;
      animation: skeleton-loading 1.5s infinite;
      border-radius: 4px;
      color: transparent;
      user-select: none;
      pointer-events: none;
    }

    .skeleton-text {
      height: 1em;
      width: 100%;
      margin: 0.25em 0;
    }

    .skeleton-text.short {
      width: 60%;
    }

    .skeleton-text.medium {
      width: 80%;
    }

    .skeleton-number {
      height: 1.2em;
      width: 3em;
      margin: 0.1em 0;
    }

    .skeleton-rank {
      height: 1em;
      width: 2.5em;
      margin: 0.1em 0;
    }

    .skeleton-minutes {
      height: 1em;
      width: 4em;
      margin: 0.1em 0;
    }

    .skeleton-username {
      height: 1em;
      width: 6em;
      margin: 0.1em 0;
    }

    @keyframes skeleton-loading {
      0% {
        background-position: -200% 0;
      }
      100% {
        background-position: 200% 0;
      }
    }

    /* Hide skeleton when data is loaded */
    .data-loaded .skeleton {
      animation: none;
      background: transparent;
      color: inherit;
    }

    /* Prevent flickering during initial load */
    .auth-dependent {
      opacity: 0;
      transition: opacity 0.3s ease-in-out;
    }

    .auth-dependent.loaded {
      opacity: 1;
    }

    /* Hide content until JavaScript determines auth state */
    .js-loading .auth-dependent {
      opacity: 0;
    }

    .js-loaded .auth-dependent {
      opacity: 1;
    }

    /* Header */
    .header {
      border-bottom: 1px solid var(--gray-200);
    }

    .header-container {
      max-width: 1320px;
      margin: 0 auto;
      padding: 16px 40px;
      height: 4rem;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 1.25rem;
    }

    .logo {
      font-size: 28px;
      font-weight: 700;
      color: #111;
      text-decoration: none;
      cursor: pointer;
      transition: color 0.2s;
    }

    .logo:hover {
      color: var(--brand-600);
    }

    .nav {
      display: flex;
      align-items: center;
      gap: 1rem;
    }

    .nav-hidden-mobile {
      display: flex;
      align-items: center;
      gap: 1rem;
    }

    .welcome {
      color: var(--gray-900);
    }

    .welcome-bold {
      font-weight: 500;
    }

    .nav-link {
      color: var(--gray-700);
      text-decoration: none;
      padding: .5rem 1rem;
      border-radius: .375rem;
      transition: .2s;
      font-weight: 500;
    }

    .nav-link:hover {
      background: var(--gray-100);
      color: var(--gray-900);
    }

    .nav-link.active {
      color: var(--gray-900);
      font-weight: 600;
    }

    .nav-cta {
      background: var(--brand-600);
      color: #fff;
      padding: .5rem 1rem;
      border-radius: .5rem;
      font-weight: 600;
      text-decoration: none;
      transition: .2s;
    }

    .nav-cta:hover {
      background: var(--brand-700);
      transform: translateY(-1px);
    }

    /* FORA Charity Header */
    .charity-header {
      background-color: var(--fora-bg);
      border-bottom: 1px solid var(--gray-200);
    }

    .charity-header-container {
      max-width: 1320px;
      margin: 0 auto;
      padding: 0.75rem 1rem;
      text-align: center;
    }

    .charity-text {
      font-size: 0.9375rem;
      color: var(--gray-800);
    }

    .charity-highlight {
      font-weight: 600;
      color: var(--brand-600);
    }

    .user-menu {
      position: relative;
    }

    .user-menu-btn {
      background: none;
      border: none;
      color: var(--gray-600);
      font-size: 0.875rem;
      cursor: pointer;
      padding: 0.5rem 0;
      display: flex;
      align-items: center;
      gap: 0.25rem;
    }

    .user-menu-btn:hover {
      color: var(--gray-900);
    }

    .user-dropdown {
      position: absolute;
      top: 100%;
      right: 0;
      background: white;
      border: 1px solid var(--gray-200);
      border-radius: 0.5rem;
      box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
      padding: 0.5rem 0;
      min-width: 120px;
      z-index: 1000;
    }

    .logout-btn {
      background: none;
      border: none;
      color: var(--gray-600);
      font-size: 0.875rem;
      cursor: pointer;
      padding: 0.5rem 1rem;
      width: 100%;
      text-align: left;
    }

    .logout-btn:hover {
      background: var(--gray-50);
      color: var(--gray-900);
    }

    /* Hero section */
    .hero {
      border-bottom: 1px solid var(--gray-200);
    }

    .hero-container {
      max-width: 1320px;
      margin: 0 auto;
      padding: 1rem 1rem;
      text-align: center;
    }

    .hero-title { 
      font-size: 1.25rem; 
      font-weight: 600; 
      color: var(--gray-900); 
      margin-bottom: 0.125rem; 
    }

    .hero-amount { 
      margin-top: 0; 
      font-size: 3.875rem; 
      font-weight: 800; 
      color: var(--brand-600); 
      letter-spacing: -0.025em; 
      font-variant-numeric: tabular-nums; 
    }

    .hero-subtitle { 
      margin-top: 0.125rem; 
      font-size: 1.125rem; 
      color: var(--gray-600); 
    }

    /* Main content */
    .main {
      max-width: 1320px;
      margin: 0 auto;
      padding: 1.5rem 1rem;
    }

    .grid {
      display: grid;
      grid-template-columns: 2fr 1fr;
      gap: 1.25rem;
      align-items: stretch;
      margin-bottom: 1.5rem;
    }

    /* Video section */
    .video-section {
      display: flex;
      flex-direction: column;
    }

    .video-container {
      position: relative;
      flex: 1;
      overflow: hidden;
      border-radius: 0.75rem 0.75rem 0 0;
      border: 1px solid var(--gray-200);
      background-color: var(--gray-200);
    }

    .video-aspect {
      position: relative;
      width: 100%;
      height: 0;
      padding-bottom: 56.25%; /* 16:9 aspect ratio */
    }

    .video-js {
      position: absolute !important;
      top: 0;
      left: 0;
      width: 100% !important;
      height: 100% !important;
    }

    .video-js video {
      width: 100% !important;
      height: 100% !important;
      object-fit: cover;
    }

    /* Hide play button when video is playing */
    .video-js.vjs-playing .vjs-big-play-button {
      display: none !important;
      visibility: hidden !important;
      opacity: 0 !important;
    }

    /* Show play button when video is paused */
    .video-js.vjs-paused .vjs-big-play-button {
      display: flex !important;
      visibility: visible !important;
      opacity: 1 !important;
    }


    .video-js .vjs-tech {
      border-radius: 0.75rem 0.75rem 0 0;
      object-fit: cover;
      width: 100% !important;
      height: 100% !important;
    }

    .video-js .vjs-big-play-button {
      width: 5rem;
      height: 5rem;
      background-color: var(--brand-600);
      border: none;
      border-radius: 50%;
      box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      margin: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      position: absolute;
    }

    .video-js .vjs-big-play-button:hover {
      background-color: var(--brand-700);
    }

    .video-js .vjs-big-play-button .vjs-icon-placeholder {
      font-size: 2.5rem;
      display: flex;
      align-items: center;
      justify-content: center;
      line-height: 1;
      width: 100%;
      height: 100%;
      margin: 0;
      padding: 0;
      position: relative;
    }

    .video-js .vjs-big-play-button .vjs-icon-placeholder::before {
      content: "▶";
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) translateY(4mm) translateX(1mm);
      font-size: 2.5rem;
      line-height: 1;
      margin: 0;
      padding: 0;
    }

    /* Hide progress bar and other unwanted controls */
    .video-js .vjs-progress-control {
      display: none !important;
    }
    
    .video-js .vjs-progress-holder {
      display: none !important;
    }
    
    .video-js .vjs-load-progress {
      display: none !important;
    }
    
    .video-js .vjs-play-progress {
      display: none !important;
    }
    
    .video-js .vjs-time-tooltip {
      display: none !important;
    }
    
    .video-js .vjs-picture-in-picture-control {
      display: none !important;
    }
    
    .video-js .vjs-fullscreen-control {
      display: none !important;
    }

    /* Prevent unwanted interactions */
    .video-js, .video-js video {
      user-select: none !important;
      -webkit-user-select: none !important;
      -moz-user-select: none !important;
      -ms-user-select: none !important;
      -webkit-touch-callout: none !important;
      -webkit-tap-highlight-color: transparent !important;
    }
    
    /* Disable drag and drop */
    .video-js video {
      pointer-events: none !important;
    }
    
    /* Re-enable pointer events for controls */
    .video-js .vjs-control-bar {
      pointer-events: auto !important;
    }
    
    .video-js .vjs-big-play-button {
      pointer-events: auto !important;
    }

    /* Hide time displays */
    .video-js .vjs-current-time,
    .video-js .vjs-duration,
    .video-js .vjs-time-control,
    .video-js .vjs-remaining-time {
      display: none !important;
    }

    .login-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.8);
      display: none;
      align-items: center;
      justify-content: center;
      border-radius: 0.75rem 0.75rem 0 0;
      z-index: 10;
    }

    .login-prompt {
      background: white;
      padding: 2rem;
      border-radius: 0.5rem;
      text-align: center;
      max-width: 300px;
    }

    .login-prompt h3 {
      margin-bottom: 1rem;
      color: var(--gray-900);
    }

    .login-prompt p {
      margin-bottom: 1.5rem;
      color: var(--gray-600);
      font-size: 0.875rem;
    }

    .video-controls {
      border-left: 1px solid var(--gray-200);
      border-right: 1px solid var(--gray-200);
      border-bottom: 1px solid var(--gray-200);
      border-radius: 0 0 0.75rem 0.75rem;
      background-color: white;
      padding: 0.75rem 1rem;
      box-shadow: 0 1px 2px rgba(16,24,40,.04), 0 1px 3px rgba(16,24,40,.1);
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 1rem;
      margin-top: 0;
    }

    .quality-text {
      font-size: 0.875rem;
      color: var(--gray-700);
    }

    .quality-number {
      font-weight: 500;
      font-variant-numeric: tabular-nums;
    }

    .upgrade-btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      background-color: var(--brand-600);
      color: white;
      padding: 0.5rem 1rem;
      border: none;
      border-radius: 0.5rem;
      font-size: 0.875rem;
      font-weight: 600;
      cursor: pointer;
      font-variant-numeric: tabular-nums;
    }

    .upgrade-btn:hover {
      background-color: var(--brand-700);
    }

    .popout-btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      background-color: #10b981;
      color: white;
      padding: 0.75rem 1.5rem;
      border: none;
      border-radius: 0.5rem;
      font-size: 0.875rem;
      font-weight: 500;
      cursor: pointer;
      transition: background-color 0.2s;
      margin-left: 0.75rem;
    }

    .popout-btn:hover {
      background-color: #059669;
    }

    .play-button {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 5rem;
      height: 5rem;
      background-color: var(--brand-600);
      border: none;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
    }

    .play-button:hover {
      background-color: var(--brand-700);
    }

    .play-icon {
      width: 2.5rem;
      height: 2.5rem;
      fill: white;
    }

    /* Progress bar section */
    .progress-section {
      border: 1px solid var(--gray-200);
      border-radius: 0.75rem;
      background-color: white;
      box-shadow: 0 1px 2px rgba(16,24,40,.04), 0 1px 3px rgba(16,24,40,.1);
    }

    .progress-content {
      padding: 0.75rem 0;
      margin: 0 0.25rem 0 -1rem;
    }

    .progress-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 0.5rem;
    }

    .partner-text {
      font-size: 0.9375rem;
      color: var(--gray-700);
      font-weight: 600;
    }

    .progress-amount {
      font-size: 0.9375rem;
      color: var(--gray-700);
      font-variant-numeric: tabular-nums;
    }

    .amount-raised {
      font-weight: 600;
      color: var(--gray-900);
    }

    .amount-goal {
      font-weight: 600;
      color: var(--gray-900);
    }

    .amount-text {
      font-weight: 400;
      color: var(--gray-600);
    }

    .progress-bar-container {
      width: 100%;
      height: 0.5rem;
      background-color: var(--gray-200);
      border-radius: 0.25rem;
      overflow: hidden;
    }

    .progress-bar-fill {
      height: 100%;
      background-color: var(--brand-600);
      border-radius: 0.25rem;
      width: 70.4%; /* $352 of $500 */
      transition: width 0.3s ease;
    }

    /* Sidebar */
    .sidebar {
      display: flex;
      flex-direction: column;
      gap: 1.5rem;
    }

    .card {
      flex: 1;
      border-radius: 0.75rem;
      border: 1px solid var(--gray-200);
      background-color: white;
      box-shadow: 0 1px 2px rgba(16,24,40,.04), 0 1px 3px rgba(16,24,40,.1);
    }

    .card-content {
      padding: 1.25rem;
    }

    .card-title {
      font-size: 1rem;
      font-weight: 600;
      color: var(--gray-900);
      margin-bottom: 1rem;
    }

    /* Impact metrics */
    .metrics {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
      font-size: 0.875rem;
    }

    .metric-row {
      display: flex;
      justify-content: space-between;
    }

    .metric-label {
      color: var(--gray-600);
    }

    .metric-value {
      font-weight: 600;
      color: var(--brand-600);
      font-variant-numeric: tabular-nums;
    }

    /* Leaderboard */
    .leaderboard {
      margin-top: 1rem;
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .leaderboard-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      background-color: var(--gray-50);
      padding: 0.5rem 1rem;
      border-radius: 0.5rem;
    }

    .leaderboard-item.current-user {
      border: 1px solid rgba(63, 157, 94, 0.4);
      background-color: white;
    }

    .leaderboard-left {
      display: flex;
      align-items: center;
      gap: 0.75rem;
    }

    .rank {
      font-size: 0.875rem;
      font-weight: 600;
      color: var(--gray-700);
      font-variant-numeric: tabular-nums;
    }

    .rank.current-user {
      color: var(--brand-600);
    }

    .username {
      font-size: 0.875rem;
      color: var(--gray-800);
    }

    .username.current-user {
      font-weight: 500;
      color: var(--brand-700);
    }

    .minutes {
      font-size: 0.875rem;
      color: var(--gray-700);
      font-variant-numeric: tabular-nums;
    }

    .minutes.current-user {
      color: var(--brand-700);
    }

    .loading {
      display: none;
      margin-top: 10px;
      color: #aaa;
    }

    /* Responsive */
    @media (max-width: 1024px) {
      .grid {
        grid-template-columns: 1fr;
      }
      
      .hero-amount {
        font-size: 2.5rem;
      }
    }

    @media (max-width: 768px) {
      .header .container {
        padding: 0 1rem;
      }
      
      .hero-container, .main {
        padding-left: 1rem;
        padding-right: 1rem;
      }
      
      .nav-hidden-mobile {
        display: none;
      }
    }

    @media (min-width: 640px) {
      .hero-amount {
        font-size: 3.75rem;
      }
      
      .hero-container, .main {
        padding-left: 1.5rem;
        padding-right: 1.5rem;
      }
    }

    @media (min-width: 1024px) {
      .hero-container, .main {
        padding-left: 2rem;
        padding-right: 2rem;
      }
      
      .upgrade-btn {
        padding: 0.5rem 1.5rem;
      }
    }

    /* Lander Styles */
    .lander-hero {
      text-align: center;
      margin-top: 0px;
      margin-bottom: 15px;
    }
    
    .lander-title-section {
      padding: 2rem 1rem;
    }
    
    .lander-title {
      font-size: 72px;
      font-weight: 900;
      color: #111;
      line-height: 1.1;
      margin-bottom: 6px;
      letter-spacing: -2px;
    }
    
    .lander-title .underline {
      background: linear-gradient(135deg, #2F7D31 0%, #4CAF50 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      text-decoration: none;
    }
    
    .lander-subtitle {
      font-size: 72px;
      font-weight: 900;
      color: #111;
      line-height: 1.1;
      letter-spacing: -2px;
    }
    
    .lander-main {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 0 40px;
      min-height: 0;
      justify-content: center;
    }
    
    /* Lander Video Container - UPDATED WITH PREMIUM ANIMATIONS */
    .lander-video-container {
      width: 100%;
      max-width: 1200px;
      height: 600px;
      background-color: #ddd;
      border-radius: 20px;
      display: flex;
      justify-content: center;
      align-items: center;
      position: relative;
      margin-bottom: 20px;
      cursor: pointer;
      text-decoration: none;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.1);
      transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      overflow: hidden;
    }
    
    .lander-video-container::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(135deg, rgba(47, 125, 49, 0.1) 0%, rgba(27, 94, 32, 0.1) 100%);
      opacity: 0;
      transition: opacity 0.4s;
    }
    
    .lander-video-container:hover::before {
      opacity: 1;
    }
    
    .lander-video-container:hover {
      transform: translateY(-8px);
      box-shadow: 0 30px 80px rgba(0, 0, 0, 0.15);
    }
    
    .lander-play-button {
      width: 90px;
      height: 90px;
      background: linear-gradient(135deg, #2F7D31 0%, #1B5E20 100%);
      border-radius: 50%;
      display: flex;
      justify-content: center;
      align-items: center;
      cursor: pointer;
      transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      box-shadow: 0 6px 20px rgba(47, 125, 49, 0.3);
      position: relative;
    }
    
    .lander-play-button::after {
      content: '';
      position: absolute;
      width: 120%;
      height: 120%;
      border: 2px solid rgba(47, 125, 49, 0.3);
      border-radius: 50%;
      animation: pulse 2s infinite;
    }
    
    @keyframes pulse {
      0%, 100% {
        transform: scale(1);
        opacity: 1;
      }
      50% {
        transform: scale(1.3);
        opacity: 0;
      }
    }
    
    .lander-video-container:hover .lander-play-button {
      transform: scale(1.15);
      box-shadow: 0 8px 25px rgba(47, 125, 49, 0.4);
    }
    
    .lander-play-button::before {
      content: '';
      width: 0;
      height: 0;
      border-left: 28px solid white;
      border-top: 16px solid transparent;
      border-bottom: 16px solid transparent;
      margin-left: 5px;
    }
    
    /* Lander Ticker Section */
    .lander-ticker-section {
      width: 100%;
      max-width: 1200px;
      margin-bottom: 20px;
    }
    
    .lander-ticker-container {
      width: 100%;
      height: 50px;
      overflow: hidden;
      position: relative;
      margin-bottom: 8px;
      mask: linear-gradient(to right, 
          transparent 0%, 
          black 1%, 
          black 99%, 
          transparent 100%);
      -webkit-mask: linear-gradient(to right, 
          transparent 0%, 
          black 1%, 
          black 99%, 
          transparent 100%);
    }
    
    .lander-ticker-container:last-child {
      margin-bottom: 0;
    }
    
    .lander-ticker {
      display: flex;
      align-items: center;
      height: 100%;
      animation-timing-function: linear;
      animation-iteration-count: infinite;
      gap: 16px;
      width: 200%;
    }
    
    .lander-ticker-top {
      animation: scrollRightLoop 32s linear infinite;
    }
    
    .lander-ticker-bottom {
      animation: scrollLeftLoop 34s linear infinite;
    }
    
    .lander-ticker-chip {
      background-color: #399B3C;
      color: white;
      padding: 10px 18px;
      border-radius: 25px;
      font-size: 15px;
      font-weight: 600;
      white-space: nowrap;
      flex-shrink: 0;
    }
    
    .lander-ticker-chip.bottom {
      background-color: #2F7D31;
    }
    
    @keyframes scrollRightLoop {
      0% {
          transform: translateX(0%);
      }
      100% {
          transform: translateX(-50%);
      }
    }
    
    @keyframes scrollLeftLoop {
      0% {
          transform: translateX(-50%);
      }
      100% {
          transform: translateX(0%);
      }
    }
    
    /* Responsive adjustments for lander */
    @media (max-width: 1200px) {
      .lander-title, .lander-subtitle {
        font-size: 56px;
      }
      
      .lander-video-container {
        height: 320px;
        max-width: 800px;
      }
    }
    
    @media (max-width: 1200px) {
      .lander-title, .lander-subtitle {
        font-size: 56px;
      }
      
      .lander-video-container {
        height: 320px;
        max-width: 800px;
      }
    }
    
    @media (max-width: 768px) {
      .header-container {
        padding: 16px 20px;
      }
      
      .lander-main {
        padding: 0 20px;
      }
      
      .lander-title, .lander-subtitle {
        font-size: 42px;
      }
      
      .lander-video-container {
        height: 250px;
        margin-bottom: 40px;
      }
      
      .nav {
        gap: 16px;
      }
      
      .nav-link {
        font-size: 14px;
      }
      
      .watch-ads-btn {
        padding: 8px 16px;
        font-size: 14px;
      }
    }

    /* Responsive */
    @media (max-width: 1024px) {
      .grid {
        grid-template-columns: 1fr;
      }
      
      .hero-amount { 
        margin-top: 0; 
        font-size: 3.875rem; 
        font-weight: 800; 
        color: var(--brand-600); 
        letter-spacing: -0.025em; 
        font-variant-numeric: tabular-nums; 
      }
    }

    @media (max-width: 768px) {
      .header-container, .charity-header-container, .hero-container, .main {
        padding-left: 1rem;
        padding-right: 1rem;
      }
      
      .nav-hidden-mobile {
        display: none;
      }
    }

    @media (min-width: 640px) {
      .hero-amount { 
        margin-top: 0; 
        font-size: 3.875rem; 
        font-weight: 800; 
        color: var(--brand-600); 
        letter-spacing: -0.025em; 
        font-variant-numeric: tabular-nums; 
      }
      
      .header-container, .charity-header-container, .hero-container, .main {
        padding-left: 1.5rem;
        padding-right: 1.5rem;
      }

      .progress-section {
        padding-left: 1.5rem;
        padding-right: 1.5rem;
      }
    }

    @media (min-width: 1024px) {
      .header-container, .charity-header-container, .hero-container, .main {
        padding-left: 2rem;
        padding-right: 2rem;
      }

      .progress-section {
        padding-left: 2rem;
        padding-right: 2rem;
      }
      
      .upgrade-btn {
        padding: 0.5rem 1.5rem;
      }
    }
  
/* === Viewport Framing (Desktop 100% Zoom) === */
@media (min-width: 1024px) {
  html, body { height: 100%; }
  body { scroll-snap-type: y mandatory; }
  .frame-snap { scroll-snap-align: start; scroll-snap-stop: always; }
  .frame-scaler { position: relative; width: 100%; }
  .frame-inner { transform-origin: top center; }
}
    /* Pop-up Ad Styles */
    .popup-ad {
      position: fixed;
      width: 384px;
      height: 384px;
      background-color: #ffffff;
      border: 3px solid #2F7D31;
      border-radius: 12px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
      z-index: 10000;
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      font-family: 'Inter', sans-serif;
      user-select: none;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
    }

    .popup-ad.show {
      display: flex;
    }

    .popup-close-btn {
      position: absolute;
      top: 12px;
      left: 12px;
      width: 32px;
      height: 32px;
      background-color: #dc2626;
      color: white;
      border: none;
      border-radius: 50%;
      font-size: 18px;
      font-weight: bold;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background-color 0.2s;
    }

    .popup-close-btn:hover {
      background-color: #b91c1c;
    }

    .popup-content {
      text-align: center;
      padding: 20px;
      font-size: 24px;
      font-weight: 700;
      color: #2F7D31;
    }

    /* Responsive popup */
    @media (max-width: 768px) {
      .popup-ad {
        width: 320px;
        height: 320px;
      }

      .popup-content {
        font-size: 20px;
      }
    }

    /* Tutorial System - Now handled by separate tutorial.html page */

    .tutorial-btn {
      padding: 8px 16px;
      border: none;
      border-radius: 6px;
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s;
    }

    .tutorial-btn-primary {
      background-color: #2F7D31;
      color: white;
    }

    .tutorial-btn-primary:hover {
      background-color: #276629;
    }

    .tutorial-btn-secondary {
      background-color: #f3f4f6;
      color: #6b7280;
    }

    .tutorial-btn-secondary:hover {
      background-color: #e5e7eb;
    }

    .tutorial-modal {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: white;
      border-radius: 16px;
      padding: 32px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
      z-index: 10004;
      text-align: center;
      max-width: 400px;
      font-family: 'Inter', sans-serif;
    }

    .tutorial-modal h2 {
      font-size: 24px;
      font-weight: 700;
      color: #333;
      margin-bottom: 16px;
    }

    .tutorial-modal p {
      font-size: 16px;
      color: #6b7280;
      margin-bottom: 24px;
      line-height: 1.5;
    }

    .tutorial-modal-buttons {
      display: flex;
      gap: 12px;
      justify-content: center;
    }

    .tutorial-modal-btn {
      padding: 12px 24px;
      border: none;
      border-radius: 8px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
      min-width: 100px;
    }

    .tutorial-modal-btn-primary {
      background-color: #2F7D31;
      color: white;
    }

    .tutorial-modal-btn-primary:hover {
      background-color: #276629;
    }

    .tutorial-modal-btn-secondary {
      background-color: #f3f4f6;
      color: #6b7280;
    }

    .tutorial-modal-btn-secondary:hover {
      background-color: #e5e7eb;
    }

    .tutorial-link {
      color: #6b7280;
      text-decoration: none;
      font-size: 14px;
      font-weight: 500;
      margin-left: 16px;
      transition: color 0.2s;
    }

    .tutorial-link:hover {
      color: #2F7D31;
    }

    .tutorial-complete {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: white;
      border-radius: 16px;
      padding: 32px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
      z-index: 10004;
      text-align: center;
      max-width: 300px;
      font-family: 'Inter', sans-serif;
    }

    .tutorial-complete h2 {
      font-size: 24px;
      font-weight: 700;
      color: #2F7D31;
      margin-bottom: 16px;
    }

    .tutorial-complete p {
      font-size: 16px;
      color: #6b7280;
      margin-bottom: 24px;
    }

    .tutorial-complete-btn {
      padding: 12px 24px;
      background-color: #2F7D31;
      color: white;
      border: none;
      border-radius: 8px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
    }

    .tutorial-complete-btn:hover {
      background-color: #276629;
    }

    /* Responsive tutorial */
    @media (max-width: 768px) {
      .tutorial-tooltip {
        max-width: 250px;
        padding: 16px;
      }

      .tutorial-modal {
        margin: 20px;
        max-width: calc(100% - 40px);
      }

      .tutorial-complete {
        margin: 20px;
        max-width: calc(100% - 40px);
      }
    }

    /* Session Conflict Toast Notifications */
    .session-toast {
      position: fixed;
      top: 20px;
      right: 20px;
      background: #e74c3c;
      color: white;
      padding: 1rem 1.5rem;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      z-index: 10000;
      animation: slideIn 0.3s ease-out, fadeOut 0.3s ease-in 2.7s;
      font-family: Arial, sans-serif;
      max-width: 350px;
    }

    .session-toast h4 {
      margin: 0 0 0.5rem 0;
      font-size: 1rem;
      font-weight: bold;
    }

    .session-toast p {
      margin: 0;
      font-size: 0.875rem;
      opacity: 0.95;
    }

    @keyframes slideIn {
      from {
        transform: translateX(400px);
        opacity: 0;
      }
      to {
        transform: translateX(0);
        opacity: 1;
      }
    }

    @keyframes fadeOut {
      from {
        opacity: 1;
      }
      to {
        opacity: 0;
      }
    }
  </style>
</head>
<body>
  <!-- Tutorial System - Now handled by separate tutorial.html page -->

  <div id="tutorialModal" class="tutorial-modal" style="display: none;">
    <h2>Welcome to Charity Stream!</h2>
    <p>Would you like a quick tutorial on how to use Charity Stream?</p>
    <div class="tutorial-modal-buttons">
      <button id="tutorialNo" class="tutorial-modal-btn tutorial-modal-btn-secondary">No</button>
      <button id="tutorialYes" class="tutorial-modal-btn tutorial-modal-btn-primary">Yes</button>
    </div>
  </div>

  <div id="tutorialComplete" class="tutorial-complete" style="display: none;">
    <h2>Tutorial Complete 🎉</h2>
    <p>You're all set! Start watching ads and making a difference.</p>
    <button id="tutorialCompleteBtn" class="tutorial-complete-btn">Get Started</button>
  </div>

  <!-- Top Nav -->
  <header class="header">
      <div class="header-container">
      <!-- LOGO (Top Left) -->
        <a href="#" class="logo" id="logoBtn">Charity Stream</a>
      
      <!-- NAVIGATION (Top Right) -->
      <nav class="nav">
        <!-- LOGGED IN USER NAV -->
        <div class="nav-hidden-mobile" id="loggedInNav" style="display: none;">
          <span class="welcome">Welcome, <span class="welcome-bold" id="usernameDisplay">User</span></span>
          <a href="/about" class="nav-link">About</a>
          <a href="/advertise" class="nav-link">Advertise</a>
          <a href="/impact" class="nav-link">Impact</a>
          <a href="#" class="nav-cta" id="watchAdsBtnLoggedIn">Watch Ads</a>
        </div>
        
        <!-- GUEST USER NAV -->
        <div class="nav-hidden-mobile" id="guestNav">
          <a href="/about" class="nav-link">About</a>
          <a href="/advertise" class="nav-link">Advertise</a>
          <a href="/impact" class="nav-link">Impact</a>
          <a href="/auth" class="nav-cta" id="watchAdsBtnGuest">Watch Ads</a>
        </div>
      </nav>
    </div>
  </header>

  <!-- FORA Charity Header (shown when authenticated) -->
  <section class="frame-scaler frame-snap" id="framed-viewport">
    <div class="frame-inner">
      <section class="charity-header" id="charityHeader" style="display: none;">
        <div class="charity-header-container">
          <div class="charity-text">Your Donations This Week Support: <span class="charity-highlight">FORA — Empowering Refugee Families Through Education</span></div>
        </div>
      </section>
      
      <!-- Hero / Total Raised (shown when authenticated) -->
      <section class="hero" id="heroSection" style="display: none;">
        <div class="hero-container">
          <h1 class="hero-title">Total Raised for Charity</h1>
          <div class="hero-amount">$832.11</div>
          <p class="hero-subtitle">Stream ads, fuel impact, compete for good.</p>
        </div>
      </section>

  <!-- Lander Hero (shown when not authenticated) -->
  <section class="lander-hero" id="landerHero">
    <div class="lander-title-section">
      <h1 class="lander-title">Change Starts <span class="underline">Here</span></h1>
      <h2 class="lander-subtitle">Join the Stream.</h2>
    </div>
  </section>

      <!-- Main Content (shown when authenticated) -->
      <main class="main" id="mainContent" style="display: none;">
    <div class="grid">
      <!-- Video Area -->
      <section class="video-section">
        <div class="video-container">
          <div class="video-aspect">
            <video
              id="my-video"
              class="video-js vjs-default-skin"
              controls
              preload="auto"
              data-setup="{}"
            >
              <source src="videos/video_1.mp4" type="video/mp4" />
              <p class="vjs-no-js">
                To view this video please enable JavaScript, and consider upgrading to a
                web browser that supports HTML5 video.
              </p>
            </video>
            
            <!-- Login overlay for non-authenticated users -->
            <div class="login-overlay" id="loginOverlay">
              <div class="login-prompt">
                <h3>Sign In Required</h3>
                <p>Please sign in to start watching ads for charity and track your impact!</p>
                <button class="watch-ads-btn" onclick="goToAuth()">Sign In / Sign Up</button>
              </div>
            </div>
          </div>
        </div>
        <div class="video-controls">
          <div class="quality-text">Quality: <span class="quality-number" id="currentQualityDisplay">HD</span></div>
          <button class="upgrade-btn" onclick="window.location.href='/subscribe'">Upgrade to get pop-out player</button>
        </div>
      </section>

      <!-- Sidebar -->
      <aside class="sidebar">
        <!-- Your Impact Card -->
        <div class="card auth-dependent">
          <div class="card-content">
            <h2 class="card-title">Your Impact</h2>
            <dl class="metrics">
              <div class="metric-row">
                <dt class="metric-label">Ads Watched Today</dt>
                <dd class="metric-value" id="adsWatchedToday"><span class="skeleton skeleton-number">0</span></dd>
              </div>
              <div class="metric-row">
                <dt class="metric-label">Total Ads Watched</dt>
                <dd class="metric-value" id="totalAdsWatched"><span class="skeleton skeleton-number">0</span></dd>
              </div>
              <div class="metric-row">
                <dt class="metric-label">Current Rank</dt>
                <dd class="metric-value" id="currentRank"><span class="skeleton skeleton-rank">#-</span></dd>
              </div>
            </dl>
          </div>
        </div>

        <!-- Leaderboard Card -->
        <div class="card auth-dependent">
          <div class="card-content">
            <h2 class="card-title">Top Ad Watchers This Month</h2>
            <ul class="leaderboard">
              <li class="leaderboard-item">
                <div class="leaderboard-left">
                  <span class="rank"><span class="skeleton skeleton-rank">#--</span></span>
                  <span class="username"><span class="skeleton skeleton-username">Loading...</span></span>
                </div>
                <span class="minutes"><span class="skeleton skeleton-minutes">0 mins</span></span>
              </li>
              <li class="leaderboard-item">
                <div class="leaderboard-left">
                  <span class="rank"><span class="skeleton skeleton-rank">#--</span></span>
                  <span class="username"><span class="skeleton skeleton-username">Loading...</span></span>
                </div>
                <span class="minutes"><span class="skeleton skeleton-minutes">0 mins</span></span>
              </li>
              <li class="leaderboard-item">
                <div class="leaderboard-left">
                  <span class="rank"><span class="skeleton skeleton-rank">#--</span></span>
                  <span class="username"><span class="skeleton skeleton-username">Loading...</span></span>
                </div>
                <span class="minutes"><span class="skeleton skeleton-minutes">0 mins</span></span>
              </li>
              <li class="leaderboard-item">
                <div class="leaderboard-left">
                  <span class="rank"><span class="skeleton skeleton-rank">#--</span></span>
                  <span class="username"><span class="skeleton skeleton-username">Loading...</span></span>
                </div>
                <span class="minutes"><span class="skeleton skeleton-minutes">0 mins</span></span>
              </li>
              <li class="leaderboard-item">
                <div class="leaderboard-left">
                  <span class="rank"><span class="skeleton skeleton-rank">#--</span></span>
                  <span class="username"><span class="skeleton skeleton-username">Loading...</span></span>
                </div>
                <span class="minutes"><span class="skeleton skeleton-minutes">0 mins</span></span>
              </li>
              <li class="leaderboard-item current-user" id="currentUserRow" style="display: none;">
                <div class="leaderboard-left">
                  <span class="rank current-user" id="userRankDisplay"><span class="skeleton skeleton-rank">#--</span></span>
                  <span class="username current-user"><span id="userLeaderboardName"><span class="skeleton skeleton-username">Loading...</span></span> (You)</span>
                </div>
                <span class="minutes current-user" id="userMinutesDisplay"><span class="skeleton skeleton-minutes">0 mins</span></span>
              </li>
            </ul>
          </div>
        </div>
      </aside>
    </div>
    
    <!-- Weekly Partner Progress Section -->
    <section class="progress-section">
      <div class="progress-content">
        <div class="progress-header">
          <div class="partner-text">Weekly Partner: Refugee FORA</div>
          <div class="progress-amount">
            <span class="amount-raised">$352</span> <span class="amount-text">raised of</span> <span class="amount-goal">$500</span> <span class="amount-text">goal</span>
          </div>
        </div>
        <div class="progress-bar-container">
          <div class="progress-bar-fill"></div>
        </div>
      </div>
    </section>
      </main>
    </div>
  </section>

  <!-- Lander Main Content (shown when not authenticated) -->
  <main class="lander-main" id="landerMain">
    <!-- Video Player -->
    <div class="lander-video-container" onclick="handlePlayButtonClick(event)">
      <div class="lander-play-button"></div>
    </div>
    
    <!-- Ticker Section -->
    <div class="lander-ticker-section">
      <!-- Top Ticker - Charities -->
      <div class="lander-ticker-container">
        <div class="lander-ticker lander-ticker-top">
          <div class="lander-ticker-chip">Habitat For Humanity +$125</div>
          <div class="lander-ticker-chip">Red Cross Foundation +$89</div>
          <div class="lander-ticker-chip">Save The Children +$156</div>
          <div class="lander-ticker-chip">World Wildlife Fund +$78</div>
          <div class="lander-ticker-chip">Doctors Without Borders +$203</div>
          <div class="lander-ticker-chip">United Way +$134</div>
          <div class="lander-ticker-chip">Feeding America +$98</div>
          <div class="lander-ticker-chip">American Cancer Society +$167</div>
          <div class="lander-ticker-chip">Habitat For Humanity +$125</div>
          <div class="lander-ticker-chip">Red Cross Foundation +$89</div>
          <div class="lander-ticker-chip">Save The Children +$156</div>
          <div class="lander-ticker-chip">World Wildlife Fund +$78</div>
          <div class="lander-ticker-chip">Doctors Without Borders +$203</div>
          <div class="lander-ticker-chip">United Way +$134</div>
          <div class="lander-ticker-chip">Feeding America +$98</div>
          <div class="lander-ticker-chip">American Cancer Society +$167</div>
        </div>
      </div>
      
      <!-- Bottom Ticker - Top Watchers -->
      <div class="lander-ticker-container">
        <div class="lander-ticker lander-ticker-bottom">
          <div class="lander-ticker-chip lander-ticker-chip-bottom">Money23: +23,428 min watched</div>
          <div class="lander-ticker-chip lander-ticker-chip-bottom">StreamKing99: +18,567 min watched</div>
          <div class="lander-ticker-chip lander-ticker-chip-bottom">CharityFan42: +15,890 min watched</div>
          <div class="lander-ticker-chip lander-ticker-chip-bottom">WatcherPro: +14,223 min watched</div>
          <div class="lander-ticker-chip lander-ticker-chip-bottom">GoodVibes88: +12,445 min watched</div>
          <div class="lander-ticker-chip lander-ticker-chip-bottom">HelpingHands: +11,234 min watched</div>
          <div class="lander-ticker-chip lander-ticker-chip-bottom">ViewForGood: +10,876 min watched</div>
          <div class="lander-ticker-chip lander-ticker-chip-bottom">StreamLover: +9,654 min watched</div>
          <div class="lander-ticker-chip lander-ticker-chip-bottom">Money23: +23,428 min watched</div>
          <div class="lander-ticker-chip lander-ticker-chip-bottom">StreamKing99: +18,567 min watched</div>
          <div class="lander-ticker-chip lander-ticker-chip-bottom">CharityFan42: +15,890 min watched</div>
          <div class="lander-ticker-chip lander-ticker-chip-bottom">WatcherPro: +14,223 min watched</div>
          <div class="lander-ticker-chip lander-ticker-chip-bottom">GoodVibes88: +12,445 min watched</div>
          <div class="lander-ticker-chip lander-ticker-chip-bottom">HelpingHands: +11,234 min watched</div>
          <div class="lander-ticker-chip lander-ticker-chip-bottom">ViewForGood: +10,876 min watched</div>
          <div class="lander-ticker-chip lander-ticker-chip-bottom">StreamLover: +9,654 min watched</div>
        </div>
      </div>
    </div>
  </main>

  <div class="loading" id="loadingIndicator">Loading...</div>

  <!-- Video.js -->
  <script src="https://vjs.zencdn.net/8.10.0/video.min.js"></script>
  
  <!-- Custom scripts -->
  <script src="script.js"></script>
  
  <script>
    // Generate and persist device fingerprint for desktop detection
    if (!localStorage.getItem('deviceFingerprint')) {
      const fingerprint = crypto.randomUUID();
      localStorage.setItem('deviceFingerprint', fingerprint);
      console.log('🔑 Generated device fingerprint:', fingerprint);
    }
    
    // ADD request debouncing and caching
    const apiRequestCache = new Map();
    const CACHE_TTL = 10000; // 10 seconds cache

    // DEBOUNCE function for API calls
    function debounce(func, wait) {
      let timeout;
      return function executedFunction(...args) {
        const later = () => {
          clearTimeout(timeout);
          func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
      };
    }

    // ADD connection quality detection
    let connectionQuality = 'good';
    let consecutiveFailures = 0;

    const apiCallWithQualityDetection = async (apiCall) => {
      try {
        const startTime = Date.now();
        const result = await apiCall();
        const duration = Date.now() - startTime;
        
        if (duration > 2000) {
          connectionQuality = 'slow';
          console.log('🐢 Slow API response detected');
        } else if (connectionQuality === 'slow' && duration < 500) {
          connectionQuality = 'good';
          console.log('✅ Connection quality improved');
        }
        
        consecutiveFailures = 0;
        return result;
        
      } catch (error) {
        consecutiveFailures++;
        console.error(`❌ API call failed (${consecutiveFailures} consecutive failures)`);
        
        if (consecutiveFailures > 3) {
          connectionQuality = 'poor';
          console.log('🔴 Poor connection quality detected, reducing API calls');
        }
        
        throw error;
      }
    };
    
    // Authentication and user management
    let currentUser = null;
    let authToken = localStorage.getItem('authToken') || null;
    let currentSessionId = null;
    let player = null;
    let isPlayerInitialized = false;
    
    // ADD session management with request coalescing
    let pendingSessionRequests = new Map();
    
    // ADD video event deduplication
    let lastPlayEvent = 0;
    let lastEndedEvent = 0;
    const PLAY_EVENT_DEBOUNCE = 1000; // 1 second between play event handlers
    const ENDED_EVENT_DEBOUNCE = 300; // 300ms between ended event handlers
    
    // ADD automatic cache clearing
    setInterval(() => {
      const now = Date.now();
      for (const [key, value] of apiRequestCache.entries()) {
        if (now - value.timestamp > CACHE_TTL * 2) {
          apiRequestCache.delete(key);
        }
      }
    }, 30000); // Clean cache every 30 seconds

    // Check authentication immediately when script loads
    authToken = localStorage.getItem('authToken');
    const userStr = localStorage.getItem('currentUser');
    
    if (authToken && userStr) {
      try {
        currentUser = JSON.parse(userStr);
        console.log('👤 Pre-loaded user data:', currentUser);
      } catch (error) {
        console.error('❌ Error parsing cached user data:', error);
      }
    }

    // Set initial UI state immediately to prevent flash
    function setInitialUIState() {
      console.log('🔧 setInitialUIState called, authToken:', !!authToken);
      
      // Add loading class to prevent flickering
      document.body.classList.add('js-loading');
      
      const loggedInNav = document.getElementById('loggedInNav');
      const guestNav = document.getElementById('guestNav');
      const watchAdsBtnLoggedIn = document.getElementById('watchAdsBtnLoggedIn');
      const watchAdsBtnGuest = document.getElementById('watchAdsBtnGuest');
      const charityHeader = document.getElementById('charityHeader');
      const heroSection = document.getElementById('heroSection');
      const landerHero = document.getElementById('landerHero');
      const mainContent = document.getElementById('mainContent');
      const landerMain = document.getElementById('landerMain');
      
      if (!authToken) {
        console.log('❌ No auth token found, showing lander content');
        
        // Show lander content
        if (guestNav) guestNav.style.display = 'flex';
        if (loggedInNav) loggedInNav.style.display = 'none';
        if (watchAdsBtnLoggedIn) watchAdsBtnLoggedIn.style.display = 'none';
        if (watchAdsBtnGuest) watchAdsBtnGuest.style.display = 'inline-flex';
        if (charityHeader) charityHeader.style.display = 'none';
        if (landerHero) landerHero.style.display = 'block';
        if (heroSection) heroSection.style.display = 'none';
        if (landerMain) landerMain.style.display = 'flex';
        if (mainContent) mainContent.style.display = 'none';
        
        return;
      }
      
      // User is authenticated, show authenticated UI
      console.log('✅ User authenticated, showing authenticated UI');
      
      const loginOverlay = document.getElementById('loginOverlay');
      const currentUserRow = document.getElementById('currentUserRow');
      
      console.log('🔍 Elements found:', {
        loggedInNav: !!loggedInNav,
        guestNav: !!guestNav,
        loginOverlay: !!loginOverlay,
        currentUserRow: !!currentUserRow,
        heroSection: !!heroSection,
        landerHero: !!landerHero,
        mainContent: !!mainContent,
        landerMain: !!landerMain
      });
      
      // Show authenticated content
      if (loggedInNav) loggedInNav.style.display = 'flex';
      if (guestNav) guestNav.style.display = 'none';
      if (watchAdsBtnLoggedIn) watchAdsBtnLoggedIn.style.display = 'inline-flex';
      if (watchAdsBtnGuest) watchAdsBtnGuest.style.display = 'none';
      if (charityHeader) charityHeader.style.display = 'block';
      if (heroSection) heroSection.style.display = 'block';
      if (landerHero) landerHero.style.display = 'none';
      if (mainContent) mainContent.style.display = 'block';
      if (landerMain) landerMain.style.display = 'none';
      if (loginOverlay) loginOverlay.style.display = 'none';
      if (currentUserRow) currentUserRow.style.display = 'flex';
      
      if (currentUser) {
        const displayName = currentUser.username || currentUser.email?.split('@')[0] || 'User';
        const usernameDisplay = document.getElementById('usernameDisplay');
        const userLeaderboardName = document.getElementById('userLeaderboardName');
        
        if (usernameDisplay) usernameDisplay.textContent = displayName;
        if (userLeaderboardName) userLeaderboardName.textContent = displayName;
        
        console.log('👤 Set display name to:', displayName);
      }
      
      // Load user info, impact, and leaderboard data when authenticated UI is shown
      if (authToken) {
        console.log('📊 Loading user data immediately for authenticated user');
        loadUserInfo().catch(error => {
          console.log('User info loading failed (non-critical):', error);
        });
      }
      
      // Mark JavaScript as loaded and show auth-dependent content
      setTimeout(() => {
        document.body.classList.remove('js-loading');
        document.body.classList.add('js-loaded');
        
        // Show auth-dependent content
        const authDependentElements = document.querySelectorAll('.auth-dependent');
        authDependentElements.forEach(element => {
          element.classList.add('loaded');
        });
      }, 100);
    }

    // Call immediately when DOM is ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', setInitialUIState);
    } else {
      setInitialUIState();
    }

    // Logo button functionality
    document.addEventListener('DOMContentLoaded', function() {
      const logoBtn = document.getElementById('logoBtn');
      if (logoBtn) {
        logoBtn.onclick = function(e) {
          e.preventDefault();
          
          if (authToken) {
            // User is logged in, go to main page
            window.location.href = '/';
          } else {
            // User is not logged in, go to sign in
            window.location.href = '/auth';
          }
        };
      }

      // Watch Ads button functionality for logged-in users
      const watchAdsBtnLoggedIn = document.getElementById('watchAdsBtnLoggedIn');
      if (watchAdsBtnLoggedIn) {
        watchAdsBtnLoggedIn.onclick = function(e) {
          e.preventDefault();
          // User is logged in, go to main page
          window.location.href = '/';
        };
      }

      // Watch Ads button functionality for guests
      const watchAdsBtnGuest = document.getElementById('watchAdsBtnGuest');
      if (watchAdsBtnGuest) {
        watchAdsBtnGuest.onclick = function(e) {
          e.preventDefault();
          // User is not logged in, go to sign in
          window.location.href = '/auth';
        };
      }
    });

    // Lander click handlers
    function handleWatchAdsClick(event) {
      event.preventDefault();
      // Redirect to sign in page
      window.location.href = '/auth';
    }

    function handlePlayButtonClick(event) {
      event.preventDefault();
      // Redirect to sign in page
      window.location.href = '/auth';
    }

    // Check authentication on page load
    window.onload = function() {
      console.log('🚀 Page loading, checking authentication...');
      
      // Check for token from URL parameters (Google OAuth callback)
      const urlParams = new URLSearchParams(window.location.search);
      const tokenFromUrl = urlParams.get('token');
      
      if (tokenFromUrl) {
        console.log('🔑 Token found in URL, storing in localStorage');
        localStorage.setItem('authToken', tokenFromUrl);
        // Clean up URL
        window.history.replaceState({}, document.title, window.location.pathname);
      }
      
      authToken = localStorage.getItem('authToken');
      const userStr = localStorage.getItem('currentUser');
      
      console.log('🔍 Auth check:', {
        hasToken: !!authToken,
        hasUser: !!userStr,
        token: authToken ? 'Present' : 'Missing'
      });
      
      // --- NEW: dispatch an auth-ready event for modules that need auth to be known
      window.dispatchEvent(new Event('authReady'));
      console.log('🔐 authReady dispatched, authToken present?', !!authToken);
      
      // UI state is already set by setInitialUIState()
      if (!authToken) {
        console.log('❌ No auth token found in window.onload, lander content should be showing');
        
        // Ensure pop-up ads are deactivated for unauthenticated users
        if (popupAdManager) {
          popupAdManager.deactivate();
        }
        
        return;
      }
      
      // User is authenticated, initialize video player
      console.log('✅ User has token, initializing authenticated video player...');
      
      // Initialize video player immediately (don't wait for loadUserInfo)
      initializeVideoPlayer();
      
      // Don't automatically load user info - only load when user interacts
      console.log('🎬 Video player initialization complete - API calls will happen on user interaction');
    };

    function showAuthenticatedUI() {
      document.getElementById('loggedInNav').style.display = 'flex';
      document.getElementById('guestNav').style.display = 'none';
      document.getElementById('loginOverlay').style.display = 'none';
      document.getElementById('currentUserRow').style.display = 'flex';
      
      // Load user data when authenticated UI is shown
      document.getElementById('usernameDisplay').textContent = 'Loading...';
      document.getElementById('userLeaderboardName').textContent = 'Loading...';
      
      // Load user info, impact, and leaderboard data when UI is shown
      loadUserInfo().catch(error => {
        console.log('User info loading failed (non-critical):', error);
      });
    }

    function showUnauthenticatedUI() {
      document.getElementById('loggedInNav').style.display = 'none';
      document.getElementById('guestNav').style.display = 'flex';
      document.getElementById('loginOverlay').style.display = 'flex';
      document.getElementById('currentUserRow').style.display = 'none';
    }

    function goToAuth() {
      window.location.href = '/auth';
    }

    function logout() {
      localStorage.removeItem('authToken');
      localStorage.removeItem('currentUser');
      authToken = null;
      currentUser = null;
      
      // Deactivate pop-up ads when user logs out
      if (popupAdManager) {
        popupAdManager.deactivate();
      }
      
      showUnauthenticatedUI();
      
      // Reinitialize video player for guests
      if (player) {
        player.dispose();
        player = null;
        isPlayerInitialized = false;
      }
      setTimeout(initializeVideoPlayerForGuests, 50);
    }

    function handleNavClick(action) {
      const token = localStorage.getItem('authToken');
      
      if (!token) {
        // Redirect to login if not authenticated
        window.location.href = '/auth';
        return;
      }

      switch (action) {
        case 'about':
          window.location.href = '/about';
          break;
        case 'impact':
          window.location.href = '/impact';
          break;
        case 'watch':
          // Already on main page, scroll to top
          window.scrollTo({ top: 0, behavior: 'smooth' });
          break;
      }
    }

    function handleGuestNavClick(action) {
      switch (action) {
        case 'about':
          window.location.href = '/about';
          break;
        case 'impact':
          window.location.href = '/impact';
          break;
        case 'watch':
          window.location.href = '/auth';
          break;
      }
    }

    function handleWatchAdsClick(event) {
      event.preventDefault();
      
      // Check if user is authenticated
      if (authToken) {
        // User is authenticated, go to main page (ad watching section)
        window.location.href = '/';
      } else {
        // User is not authenticated, redirect to auth page
        window.location.href = '/auth';
      }
    }

    function toggleUserMenu() {
      const dropdown = document.getElementById('userDropdown');
      dropdown.style.display = dropdown.style.display === 'none' ? 'block' : 'none';
    }

    // Close dropdown when clicking outside
    document.addEventListener('click', function(event) {
      const userMenu = document.querySelector('.user-menu');
      const dropdown = document.getElementById('userDropdown');
      
      if (userMenu && !userMenu.contains(event.target)) {
        dropdown.style.display = 'none';
      }
    });

    // Load fresh user info from server
    async function loadUserInfo() {
      try {
        console.log('📡 Loading user info with token:', authToken ? 'Present' : 'Missing');
        const response = await fetch('/api/auth/me', {
          headers: {
            'Authorization': `Bearer ${authToken}`
          }
        });

        console.log('📡 User info response status:', response.status);
        if (response.ok) {
          const result = await response.json();
          console.log('👤 User info received:', result);
          currentUser = result.user;
          localStorage.setItem('currentUser', JSON.stringify(currentUser));
          
          // Update UI with user data (remove skeleton classes)
          const displayName = currentUser.username || currentUser.email?.split('@')[0] || 'User';
          const usernameElement = document.getElementById('usernameDisplay');
          const userLeaderboardElement = document.getElementById('userLeaderboardName');
          
          if (usernameElement) {
            usernameElement.innerHTML = displayName;
            usernameElement.classList.add('data-loaded');
          }
          
          if (userLeaderboardElement) {
            userLeaderboardElement.innerHTML = displayName;
            userLeaderboardElement.classList.add('data-loaded');
          }
          
          // Load user impact and leaderboard data
          loadUserImpact();
          loadLeaderboard();
        }
      } catch (error) {
        console.error('Error loading user info:', error);
      }
    }

    // Initialize video player for guests (no functionality)
    function initializeVideoPlayerForGuests() {
      // CRITICAL: Don't initialize guest player if user is authenticated
      const token = localStorage.getItem('authToken');
      if (token) {
        console.log('🎬 User is authenticated, skipping guest player initialization');
        return;
      }
      
      // Prevent multiple initializations
      if (isPlayerInitialized) {
        console.log('🎬 Guest player already initialized, skipping...');
        return;
      }
      
      // Dispose any existing player
      if (player) {
        player.dispose();
        player = null;
        isPlayerInitialized = false;
      }
      
      // Wait for Video.js to be available
      if (typeof videojs === 'undefined') {
        setTimeout(initializeVideoPlayerForGuests, 50);
        return;
      }
      
      try {
        player = videojs('my-video', {
          controls: false,
          autoplay: false,
          preload: 'none',
          fluid: true
        });

        // Intercept play attempts and show login
        player.on('play', function(e) {
          e.preventDefault();
          player.pause();
          document.getElementById('loginOverlay').style.display = 'flex';
          return false;
        });

        // Also intercept the big play button click
        player.on('loadstart', function() {
          const bigPlayButton = player.el().querySelector('.vjs-big-play-button');
          if (bigPlayButton) {
            bigPlayButton.addEventListener('click', function(e) {
              e.preventDefault();
              e.stopPropagation();
              document.getElementById('loginOverlay').style.display = 'flex';
              return false;
            });
          }
        });
        
        console.log('Guest video player initialized');
        isPlayerInitialized = true;
      } catch (error) {
        console.error('Error initializing guest video player:', error);
      }
    }

    // Complete a watch session
    async function completeWatchSession(sessionId, durationSeconds, completed, pausedCount) {
      if (!authToken || !sessionId) return;

      try {
        const response = await fetch('/api/tracking/complete-session', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${authToken}`
          },
          body: JSON.stringify({
            sessionId: sessionId,
            durationSeconds: durationSeconds,
            completed: completed,
            pausedCount: pausedCount || 0
          })
        });

        if (response.ok) {
          const data = await response.json();
          console.log('📺 Session completed successfully:', data);
        } else {
          console.error('Failed to complete session:', response.status);
        }
      } catch (error) {
        if (error.name === 'AbortError') {
          console.log('📺 Session completion request timed out (non-critical)');
        } else {
          console.error('Error completing session:', error);
        }
      }
    }

    // SIMPLIFIED session starting - with retry logic
    async function startWatchSessionWithRetry(videoTitle, quality, maxRetries = 2) {
      for (let attempt = 0; attempt < maxRetries; attempt++) {
        try {
          const sessionId = await startWatchSession(videoTitle, quality);
          if (sessionId) return sessionId;
        } catch (error) {
          if (error.status === 429) {
            // Wait longer between retries for rate limits
            await new Promise(resolve => setTimeout(resolve, 2000 * (attempt + 1)));
          }
        }
      }
      return null;
    }

    // ============================================================
    // 🔍 DEBUGGING: Frontend request tracker
    // ============================================================
    const frontendRequestTracker = {
      requests: [],
      startTime: Date.now(),
      
      log(endpoint, method = 'POST', status, duration) {
        const request = {
          timestamp: Date.now(),
          timeString: new Date().toLocaleTimeString(),
          endpoint: endpoint,
          method: method,
          status: status,
          duration: duration,
          stackTrace: new Error().stack.split('\n').slice(2, 5) // Get caller info
        };
        
        this.requests.push(request);
        
        // Log to console with color coding
        const emoji = status === 429 ? '🚨' : status >= 400 ? '❌' : '✅';
        console.log(`${emoji} [${request.timeString}] ${method} ${endpoint} - ${status} (${duration}ms)`);
        
        if (status === 429) {
          console.error('🚨 429 ERROR DETAILS:');
          console.error('   Caller stack trace:', request.stackTrace);
          this.printSummary();
        }
        
        // Keep only last 100 requests
        if (this.requests.length > 100) {
          this.requests.shift();
        }
      },
      
      printSummary() {
        console.log('\n========================================');
        console.log('📊 FRONTEND REQUEST SUMMARY');
        console.log('========================================');
        
        const uptimeMinutes = (Date.now() - this.startTime) / 60000;
        const endpointCounts = {};
        const last60Seconds = this.requests.filter(r => Date.now() - r.timestamp < 60000);
        
        this.requests.forEach(r => {
          const key = `${r.method} ${r.endpoint}`;
          endpointCounts[key] = (endpointCounts[key] || 0) + 1;
        });
        
        console.log(`Total requests: ${this.requests.length}`);
        console.log(`Uptime: ${uptimeMinutes.toFixed(2)} minutes`);
        console.log(`Rate: ${(this.requests.length / uptimeMinutes).toFixed(2)} req/min`);
        console.log(`Last 60 seconds: ${last60Seconds.length} requests`);
        console.log('\nTop endpoints:');
        
        Object.entries(endpointCounts)
          .sort((a, b) => b[1] - a[1])
          .slice(0, 10)
          .forEach(([endpoint, count]) => {
            const perMinute = (count / uptimeMinutes).toFixed(2);
            console.log(`  ${endpoint}: ${count} total (${perMinute}/min)`);
          });
        
        console.log('\nRecent 429 errors:');
        const recent429s = this.requests.filter(r => r.status === 429).slice(-5);
        recent429s.forEach(r => {
          console.log(`  ${r.timeString} - ${r.endpoint}`);
          console.log(`    Called from:`, r.stackTrace[0]);
        });
        
        console.log('========================================\n');
      },
      
      getStats() {
        const uptimeMinutes = (Date.now() - this.startTime) / 60000;
        const last60Seconds = this.requests.filter(r => Date.now() - r.timestamp < 60000);
        const errors = this.requests.filter(r => r.status >= 400);
        
        return {
          totalRequests: this.requests.length,
          uptimeMinutes: uptimeMinutes.toFixed(2),
          requestsPerMinute: (this.requests.length / uptimeMinutes).toFixed(2),
          last60Seconds: last60Seconds.length,
          totalErrors: errors.length,
          total429s: this.requests.filter(r => r.status === 429).length
        };
      }
    };

    // Print summary every 30 seconds
    setInterval(() => {
      frontendRequestTracker.printSummary();
    }, 30000);

    // Expose to window for manual inspection
    window.debugRequests = frontendRequestTracker;

    // Tracked fetch wrapper
    async function trackedFetch(url, options = {}) {
      const method = options.method || 'GET';
      const startTime = performance.now();
      
      try {
        const response = await fetch(url, options);
        const duration = Math.round(performance.now() - startTime);
        frontendRequestTracker.log(url, method, response.status, duration);
        return response;
      } catch (error) {
        const duration = Math.round(performance.now() - startTime);
        frontendRequestTracker.log(url, method, 'ERROR', duration);
        throw error;
      }
    }

    // Global lock to prevent rapid-fire session starts
    let sessionStartInProgress = false;
    const SESSION_START_COOLDOWN = 3000; // 3 seconds between session starts
    let lastSessionStartTime = 0;

    // Global tracking variables (moved outside initializeVideoPlayer)
    let currentAdTrackingId = null;
    let isAdPlaying = false;
    let adStartTime = null;
    let accumulatedAdTime = 0;
    let sessionStartTime = null;
    let currentVideoStartTime = null;
    let pausedCount = 0;

    // Start a watch session with request coalescing
    async function startWatchSession(videoName, quality) {
      if (!authToken) return null;
      
      // Layer 1: Function-level lock to prevent rapid-fire calls
      const now = Date.now();
      if (sessionStartInProgress || (now - lastSessionStartTime) < SESSION_START_COOLDOWN) {
        console.log('⏸️ Session start blocked - cooldown active');
        return null;
      }
      
      sessionStartInProgress = true;
      lastSessionStartTime = now;
      
      try {
        // Check circuit breaker
        if (!circuitBreaker.canMakeRequest()) {
          console.log('⏸️ Circuit breaker open - skipping request');
          return null;
        }

      const requestKey = `start_session_${videoName}_${quality}`;
      
      // If same request is already pending, return that promise
      if (pendingSessionRequests.has(requestKey)) {
        console.log('⏸️ Reusing pending session request');
        return pendingSessionRequests.get(requestKey);
      }

      const sessionPromise = (async () => {
        try {
          // Add timeout to prevent hanging
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), 5000); // 5 second timeout

          const response = await trackedFetch('/api/tracking/start-session', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${authToken}`
            },
            body: JSON.stringify({
              videoName: videoName,
              quality: quality
            }),
            signal: controller.signal
          });

          clearTimeout(timeoutId);

          if (response.ok) {
            circuitBreaker.recordSuccess();
            const result = await response.json();
            currentSessionId = result.sessionId;
            console.log('📺 Watch session started:', result.sessionId);
            return result.sessionId;
          } else if (response.status === 409) {
            // Session conflict detected (desktop app active)
            const errorData = await response.json();
            console.log('🚫 Session conflict detected (409):', errorData.message);
            
            // FORCE PAUSE VIDEO
            if (player) {
              player.pause();
              console.log('✅ Video paused due to 409 conflict');
            }
            
            // Show conflict toast
            showConflictToast();
            
            // No monitoring needed - server handles conflicts
            
            return null; // Session not started due to conflict
          } else if (response.status === 429) {
            console.log('⏳ Rate limited, retrying session start later...');
            circuitBreaker.recordFailure();
            // Don't retry immediately on rate limit
            return null;
          } else {
            circuitBreaker.recordFailure();
            throw new Error(`HTTP ${response.status}`);
          }
        } catch (error) {
          if (error.name === 'AbortError') {
            console.log('📺 Watch session request timed out (non-critical)');
          } else {
            console.error('Error starting watch session:', error);
            circuitBreaker.recordFailure();
          }
          return null;
        } finally {
          // Clean up pending request
          pendingSessionRequests.delete(requestKey);
        }
      })();
      
      pendingSessionRequests.set(requestKey, sessionPromise);
      return sessionPromise;
      } finally {
        // Always release the lock after a delay
        setTimeout(() => {
          sessionStartInProgress = false;
        }, 1000);
      }
    }

    // Start ad tracking
    async function startAdTracking(sessionId) {
      if (!authToken || !sessionId) return null;

      try {
        const response = await trackedFetch('/api/tracking/start-ad', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${authToken}`
          },
          body: JSON.stringify({
            sessionId: sessionId
          })
        });

        if (response.ok) {
          const result = await response.json();
          console.log('📺 Ad tracking started:', result.adTrackingId);
          return result.adTrackingId;
        }
      } catch (error) {
        console.error('Error starting ad tracking:', error);
      }
      return null;
    }

    // Complete ad tracking
    async function completeAdTracking(adTrackingId, durationSeconds, completed = true) {
      if (!authToken || !adTrackingId) {
        console.log('❌ MISSING AUTH TOKEN OR AD TRACKING ID:', {
          hasAuthToken: !!authToken,
          adTrackingId: adTrackingId
        });
        return;
      }

      console.log('🚀 COMPLETE-AD-TRACKING CALLED:', {
        adTrackingId: adTrackingId,
        durationSeconds: durationSeconds,
        completed: completed
      });

      try {
        const response = await trackedFetch('/api/tracking/complete-ad', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${authToken}`
          },
          body: JSON.stringify({
            adTrackingId: adTrackingId,
            durationSeconds: durationSeconds,
            completed: completed
          })
        });

        console.log('📡 COMPLETE-AD RESPONSE:', {
          status: response.status,
          ok: response.ok
        });

        if (response.ok) {
          console.log('✅ Ad tracking completed successfully:', durationSeconds, 'seconds');
          
          // CRITICAL FIX: Invalidate cache and force immediate refresh for real-time updates
          console.log('🔄 Clearing cache and forcing immediate UI refresh');
          userImpactCache = null; // Clear cache to force fresh data
          if (impactRefreshDebounce) {
            clearTimeout(impactRefreshDebounce);
            impactRefreshDebounce = null;
          }
          
          // Force immediate refresh without cache or debounce
          await loadUserImpact(true, true); // Force refresh + skip debounce
          loadLeaderboard();
        } else {
          console.error('❌ Complete-ad API returned error:', response.status);
          const errorText = await response.text();
          console.error('❌ Error response:', errorText);
        }
      } catch (error) {
        console.error('❌ Error completing ad tracking:', error);
      }
    }

    // Cache user impact data to prevent excessive API calls
    let userImpactCache = null;
    const IMPACT_CACHE_TTL = 5000; // 5 seconds (reduced for more responsive updates)
    let impactRefreshDebounce = null;

    // Load user impact data with caching and debouncing
    async function loadUserImpact(forceRefresh = false, skipDebounce = false) {
      if (!authToken) return;

      // Bypass cache if force refresh requested (for real-time ad updates)
      if (!forceRefresh && userImpactCache && (Date.now() - userImpactCache.timestamp) < IMPACT_CACHE_TTL) {
        console.log('📊 Using cached impact data');
        updateImpactUI(userImpactCache.data);
        return;
      }

      // Clear any existing debounce if skipping
      if (skipDebounce && impactRefreshDebounce) {
        clearTimeout(impactRefreshDebounce);
        impactRefreshDebounce = null;
      }

      // Skip debounce for immediate ad updates (real-time UI refresh)
      if (skipDebounce) {
        console.log('⚡ Loading impact data immediately (skip debounce for ad completion)');
        try {
          const response = await trackedFetch('/api/user/impact?force=true', {
          headers: {
            'Authorization': `Bearer ${authToken}`
          }
        });

        if (response.ok) {
          const result = await response.json();
          const impact = result.impact;
            
            // Cache the result
            userImpactCache = {
              data: impact,
              timestamp: Date.now()
            };
            
            updateImpactUI(impact);
            console.log('✅ Impact UI updated immediately after ad completion');
          }
        } catch (error) {
          console.error('Error loading user impact:', error);
        }
        return;
      }

      // Keep debounce for other calls (non-ad completion updates)
      if (impactRefreshDebounce) {
        clearTimeout(impactRefreshDebounce);
      }
      
      impactRefreshDebounce = setTimeout(async () => {
        try {
          const response = await trackedFetch('/api/user/impact', {
            headers: {
              'Authorization': `Bearer ${authToken}`
            }
          });

          if (response.ok) {
            const result = await response.json();
            const impact = result.impact;
            
            // Cache the result
            userImpactCache = {
              data: impact,
              timestamp: Date.now()
            };
            
            updateImpactUI(impact);
          }
        } catch (error) {
          console.error('Error loading user impact:', error);
        }
      }, 1000); // Wait 1 second before making the call
    }

    // Update UI with impact data (extracted for reuse)
    function updateImpactUI(impact) {
      console.log('🎨 UPDATING IMPACT UI:', {
        adsWatchedToday: impact.adsWatchedToday,
        totalAdsWatched: impact.totalAdsWatched,
        watchTimeMinutes: impact.watchTimeMinutes,
        currentRank: impact.currentRank,
        timestamp: new Date().toLocaleTimeString()
      });
          
          // Update UI with impact data (remove skeleton classes)
          const adsWatchedElement = document.getElementById('adsWatchedToday');
          const totalAdsElement = document.getElementById('totalAdsWatched');
          const rankElement = document.getElementById('currentRank');
          
          if (adsWatchedElement) {
        const oldValue = adsWatchedElement.innerHTML;
            adsWatchedElement.innerHTML = impact.adsWatchedToday;
            adsWatchedElement.classList.add('data-loaded');
        console.log(`📊 Ads Today: ${oldValue} → ${impact.adsWatchedToday}`);
          }
          
          if (totalAdsElement) {
        const oldValue = totalAdsElement.innerHTML;
            totalAdsElement.innerHTML = impact.totalAdsWatched;
            totalAdsElement.classList.add('data-loaded');
        console.log(`📊 Total Ads: ${oldValue} → ${impact.totalAdsWatched}`);
          }
          
          // Show dash for 0 minutes, otherwise show rank number
          const rankDisplay = impact.watchTimeMinutes === 0 ? "-" : `#${impact.currentRank}`;
          if (rankElement) {
            rankElement.innerHTML = rankDisplay;
            rankElement.classList.add('data-loaded');
          }
          
          document.getElementById('userMinutesDisplay').innerHTML = `${impact.watchTimeMinutes} mins`;
          
          // Update user rank in leaderboard
          const userRankElement = document.getElementById('userRankDisplay');
          if (userRankElement) {
            userRankElement.innerHTML = rankDisplay;
            userRankElement.classList.add('data-loaded');
          }
      
      console.log('✅ Impact UI update completed');
    }

    // Load leaderboard data
    async function loadLeaderboard() {
      if (!authToken) return;

      try {
        const response = await trackedFetch('/api/leaderboard/monthly?limit=5', {
          headers: {
            'Authorization': `Bearer ${authToken}`
          }
        });

        if (response.ok) {
          const result = await response.json();
          const leaderboard = result.leaderboard;
          
          // Update leaderboard UI
          const leaderboardContainer = document.querySelector('.leaderboard');
          if (leaderboardContainer) {
            // Clear existing items except the current user row
            const currentUserRow = document.getElementById('currentUserRow');
            leaderboardContainer.innerHTML = '';
            
            // Add leaderboard items
            leaderboard.forEach((user, index) => {
              const item = document.createElement('li');
              item.className = 'leaderboard-item';
              item.innerHTML = `
                <div class="leaderboard-left">
                  <span class="rank">#${user.rank}</span>
                  <span class="username">${user.username}</span>
                </div>
                <span class="minutes">${user.minutesWatched} mins</span>
              `;
              leaderboardContainer.appendChild(item);
            });
            
            // Add placeholder items if fewer than 5 users
            for (let i = leaderboard.length; i < 5; i++) {
              const item = document.createElement('li');
              item.className = 'leaderboard-item';
              item.innerHTML = `
                <div class="leaderboard-left">
                  <span class="rank">-</span>
                  <span class="username">Spot is open!</span>
                </div>
                <span class="minutes">0 mins</span>
              `;
              leaderboardContainer.appendChild(item);
            }
            
            // Add current user row if it exists
            if (currentUserRow) {
              leaderboardContainer.appendChild(currentUserRow);
            }
            
            // Mark leaderboard as loaded
            leaderboardContainer.classList.add('data-loaded');
          }
          
          console.log('🏆 Leaderboard data loaded:', leaderboard);
        }
      } catch (error) {
        console.error('Error loading leaderboard:', error);
      }
    }

    // ========== EVENT-DRIVEN ARCHITECTURE (NO POLLING) ==========
    
    // No more polling! Server handles all conflict detection automatically.
    // Client only makes requests when user takes action (clicks play).
    
    // SIMPLE showConflictToast function
    function showConflictToast() {
      const existingToast = document.querySelector('.session-toast');
      if (existingToast) existingToast.remove();

      const toast = document.createElement('div');
      toast.className = 'session-toast';
      toast.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: #e74c3c;
        color: white;
        padding: 15px;
        border-radius: 8px;
        z-index: 10000;
        max-width: 300px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      `;
      
      toast.innerHTML = `
        <h4 style="margin: 0 0 8px 0;">Desktop App Detected</h4>
        <p style="margin: 0 0 10px 0; font-size: 14px;">Close the desktop app to watch on the website.</p>
        <button onclick="manualCleanup()" style="padding: 6px 12px; background: white; color: #e74c3c; border: none; border-radius: 4px; cursor: pointer; font-size: 12px; font-weight: bold;">
          Clear Sessions
        </button>
      `;
      
      document.body.appendChild(toast);
      
      // Auto-remove after 8 seconds
      setTimeout(() => {
        if (toast.parentNode) {
        toast.remove();
        }
      }, 8000);
    }
    
    // Manual cleanup function - no longer needed with event-driven architecture
    async function manualCleanup() {
      console.log('✅ Manual cleanup - no longer needed with server-side session management');
      alert('Server now handles session conflicts automatically. Try refreshing the page.');
      location.reload();
    }

    // ========== CIRCUIT BREAKER PATTERN ==========
    
    // Circuit breaker to prevent overwhelming the server
    const circuitBreaker = {
      failures: 0,
      lastFailureTime: 0,
      isOpen: false,
      threshold: 5, // Open circuit after 5 failures
      timeout: 30000, // Stay open for 30 seconds
      
      recordSuccess() {
        this.failures = 0;
        this.isOpen = false;
      },
      
      recordFailure() {
        this.failures++;
        this.lastFailureTime = Date.now();
        
        if (this.failures >= this.threshold) {
          this.isOpen = true;
          console.error('🚨 Circuit breaker opened - too many failures. Waiting 30 seconds...');
          
          setTimeout(() => {
            this.failures = 0;
            this.isOpen = false;
            console.log('✅ Circuit breaker reset');
          }, this.timeout);
        }
      },
      
      canMakeRequest() {
        return !this.isOpen;
      }
    };

    // ========== ADVERTISER INFO SYSTEM ==========
    
    let currentAdvertiserInfo = null;

    // Cache advertiser info to avoid repeated lookups
    const advertiserInfoCache = new Map();

    // Function to fetch advertiser info for current video
    async function fetchAdvertiserInfo(videoFilename) {
      // Check cache first
      if (advertiserInfoCache.has(videoFilename)) {
        const cached = advertiserInfoCache.get(videoFilename);
        currentAdvertiserInfo = cached.hasAdvertiser ? cached.advertiser : null;
        if (cached.hasAdvertiser) {
          showInfoButton();
        } else {
          hideInfoButton();
        }
        return;
      }
      
      try {
        const response = await trackedFetch(`/api/videos/${videoFilename}/advertiser`, {
            headers: {
            'Authorization': `Bearer ${authToken}`
          }
        });
        
        if (response.status === 429) {
          console.log('⏸️ Rate limited on advertiser lookup - backing off');
          circuitBreaker.recordFailure();
          
          // Extract retry-after if available
          const retryAfter = response.headers.get('retry-after');
          const waitTime = retryAfter ? parseInt(retryAfter) * 1000 : 5000;
          
          console.log(`⏳ Waiting ${waitTime}ms before retrying advertiser lookup`);
          
          // Don't retry automatically - just show no advertiser info
          currentAdvertiserInfo = null;
          hideInfoButton();
          return;
        }
        
        const data = await response.json();
        
        // Cache the result
        advertiserInfoCache.set(videoFilename, data);
        
        if (data.hasAdvertiser) {
          currentAdvertiserInfo = data.advertiser;
          console.log(`📢 Advertiser found: ${data.advertiser.company_name}`);
          showInfoButton();
        } else {
          currentAdvertiserInfo = null;
          hideInfoButton();
        }
      } catch (error) {
        console.log('Error fetching advertiser info:', error);
        circuitBreaker.recordFailure();
        hideInfoButton();
      }
    }

    // Function to create and show info button
    function showInfoButton() {
      // Remove existing button if any
      hideInfoButton();
      
      if (!currentAdvertiserInfo) return;
      
      const infoButton = document.createElement('button');
      infoButton.id = 'advertiser-info-btn';
      infoButton.innerHTML = 'ℹ️';
      infoButton.title = `Learn about ${currentAdvertiserInfo.company_name}`;
      infoButton.style.cssText = `
        position: absolute;
        top: 10px;
        right: 10px;
        z-index: 1000;
        background: rgba(0,0,0,0.7);
        color: white;
        border: none;
        border-radius: 50%;
        width: 30px;
        height: 30px;
        font-size: 16px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.2s ease;
      `;
      
      // Add hover effect
      infoButton.addEventListener('mouseenter', () => {
        infoButton.style.background = 'rgba(0,0,0,0.9)';
        infoButton.style.transform = 'scale(1.1)';
      });
      
      infoButton.addEventListener('mouseleave', () => {
        infoButton.style.background = 'rgba(0,0,0,0.7)';
        infoButton.style.transform = 'scale(1)';
      });
      
      infoButton.addEventListener('click', () => {
        if (currentAdvertiserInfo && currentAdvertiserInfo.website_url) {
          console.log(`🔗 Opening advertiser website: ${currentAdvertiserInfo.website_url}`);
          window.open(currentAdvertiserInfo.website_url, '_blank', 'noopener,noreferrer');
        }
      });
      
      // Add button to video player container
      const videoContainer = document.getElementById('video-container') || document.querySelector('.video-js');
      if (videoContainer) {
        videoContainer.style.position = 'relative';
        videoContainer.appendChild(infoButton);
      }
    }

    function hideInfoButton() {
      const existingBtn = document.getElementById('advertiser-info-btn');
      if (existingBtn) {
        existingBtn.remove();
      }
    }

    // Call this when video changes
    function onVideoChanged(videoFilename) {
      fetchAdvertiserInfo(videoFilename);
    }

    // ========== END ADVERTISER INFO SYSTEM ==========

    // Initialize full video player functionality for authenticated users
    function initializeVideoPlayer() {
      if (!authToken) {
        console.log('🎬 No auth token, skipping authenticated player initialization');
        return;
      }
      
      // Prevent multiple initializations
      if (isPlayerInitialized) {
        console.log('🎬 Player already initialized, skipping...');
        return;
      }

      console.log('🎬 Initializing authenticated video player...');
      console.log('🔐 Auth token present:', !!authToken);

      // Don't check for conflicts during initialization - only check when user tries to play

      // Dispose existing player if any
      if (player) {
        player.dispose();
        player = null;
        isPlayerInitialized = false;
      }
      
      // Wait for Video.js to be available with shorter timeout
      if (typeof videojs === 'undefined') {
        console.log('🎬 Video.js not ready, retrying in 50ms...');
        setTimeout(initializeVideoPlayer, 50);
        return;
      }
      
      try {
        player = videojs('my-video', {
          controls: true,
          autoplay: false,
          preload: 'auto',
          fluid: true,
          loop: false, // We'll handle looping manually
          controlBar: {
            progressControl: false,
            fullscreenToggle: false,
            pictureInPictureToggle: false,
            currentTimeDisplay: false,
            timeDivider: false,
            durationDisplay: false,
            remainingTimeDisplay: false,
            volumePanel: false,
            playbackRateMenuButton: false,
            chaptersButton: false,
            descriptionsButton: false,
            subtitlesButton: false,
            captionsButton: false,
            audioTrackButton: false
          }
        });

        const loadingIndicator = document.getElementById("loadingIndicator");
        
        // DYNAMIC PLAYLIST FROM BACKEND
        let playlist = [];
        let videoUrls = {}; // Map video names to R2 URLs
        let currentIndex = 0;
        let currentQuality = "standard"; // Changed from quality-based to standard
        let isQualitySwitching = false;
        let isInitialLoad = true;
        let isPlaying = false;
        
        // Fetch playlist from backend dynamically
        async function initializePlaylist() {
          try {
            console.log('🔄 Fetching dynamic playlist from backend...');
            const response = await trackedFetch('/api/videos/playlist', {
              headers: {
                'Authorization': `Bearer ${authToken}`
              }
            });
            const data = await response.json();
            
            // Extract video names and URLs from backend response
            playlist = data.videos.map(video => {
              const videoName = video.title; // e.g., "video_1"
              videoUrls[videoName] = video.videoUrl; // Store the full R2 URL
              return videoName;
            });
            
            console.log('✅ Dynamic playlist loaded from R2:', playlist);
            console.log('✅ Video URLs mapped:', videoUrls);
            
            return true;
          } catch (error) {
            console.error('❌ Failed to load dynamic playlist, using fallback:', error);
            // Fallback to hardcoded playlist
            playlist = ['video_1', 'video_2', 'video_3', 'video_4', 'video_5'];
            
            // Initialize fallback URLs for hardcoded playlist
            playlist.forEach(videoName => {
              videoUrls[videoName] = `https://pub-5077a490479046dbac97642d6ea9aa70.r2.dev/${videoName}.mp4`;
            });
            
            console.log('⚠️ Using fallback playlist:', playlist);
            return false;
          }
        }

        function getVideoUrl(videoName) {
          // Use direct R2 URLs for better performance and reliability
          const R2_BASE_URL = 'https://pub-5077a490479046dbac97642d6ea9aa70.r2.dev';
          const directUrl = `${R2_BASE_URL}/${videoName}.mp4`;
          
          console.log(`🎬 Using direct R2 URL for video: ${videoName}`);
          console.log(`🎬 Direct URL: ${directUrl}`);
          
          return directUrl;
        }

        function getCurrentVideoSource() {
          const videoName = playlist[currentIndex];
          return {
            src: getVideoUrl(videoName),
            type: "video/mp4"
          };
        }

        function updateQualityDisplay() {
          document.getElementById('currentQualityDisplay').textContent = "HD";
        }

        function loadVideoWithQuality(index) {
          if (index >= playlist.length) {
            console.log(`⚠️ Index ${index} is out of bounds for playlist length ${playlist.length}`);
            return;
          }
          
          console.log(`🎬 loadVideoWithQuality called with index: ${index}`);
          console.log(`🎬 Current playlist:`, playlist);
          
          currentIndex = index;
          const source = getCurrentVideoSource();
          console.log(`🎬 Loading video ${index + 1} (${playlist[index]}): ${source.src}`);
          console.log(`🎬 Full video path: videos/${playlist[index]}.mp4`);
          
          // Load the video
          player.src(source);
          updateQualityDisplay();
          
          // Fetch advertiser info for this video
          const videoFilename = `${playlist[index]}.mp4`;
          onVideoChanged(videoFilename);
          
          player.one('loadeddata', () => {
            console.log('✅ Video loaded successfully');
            
            // Auto-play when video loads (both initial and subsequent videos)
            setTimeout(() => {
              if (window.isTutorialActive) {
                console.log('⏸ Video auto-play blocked until tutorial dismissed');
              } else {
                // Check if this is a new user who hasn't manually started playback yet
                const isNewUser = localStorage.getItem('charityStream_newUser') === 'true';
                const hasUserStartedPlayback = localStorage.getItem('charityStream_userStartedPlayback') === 'true';
                
                if (isNewUser && !hasUserStartedPlayback) {
                  console.log('⏸ New user - video stays paused until user clicks play');
                } else {
                  console.log('🎬 Attempting to auto-play video...');
                  player.play().catch(error => {
                    console.log('Auto-play prevented:', error);
                  });
                }
              }
            }, 100);
            
            // Mark initial load as complete
            if (isInitialLoad) {
              isInitialLoad = false;
            }
          });
          
          // Don't start session automatically - only start when user actually plays video
          console.log('🎬 Video player initialized - session will start when user plays video');
        }

        function disableDoubleClickFullscreen() {
          player.off('dblclick');
          const videoEl = player.el();
          const videoElement = videoEl.querySelector('video');
          
          const preventDoubleClick = (e) => {
            e.preventDefault();
            e.stopPropagation();
            console.log('🚫 Double-click prevented');
            return false;
          };
          
          const preventRightClick = (e) => {
            e.preventDefault();
            e.stopPropagation();
            console.log('🚫 Right-click prevented');
            return false;
          };
          
          // Prevent double-click on video player
          videoEl.addEventListener('dblclick', preventDoubleClick, true);
          if (videoElement) {
            videoElement.addEventListener('dblclick', preventDoubleClick, true);
          }
          
          // Prevent right-click context menu
          videoEl.addEventListener('contextmenu', preventRightClick, true);
          if (videoElement) {
            videoElement.addEventListener('contextmenu', preventRightClick, true);
          }
          
          // Disable fullscreen functionality
          player.requestFullscreen = function() {
            console.log('🚫 Fullscreen disabled');
            return Promise.resolve();
          };
          
          // Disable picture-in-picture
          if (videoElement && videoElement.requestPictureInPicture) {
            videoElement.requestPictureInPicture = function() {
              console.log('🚫 Picture-in-picture disabled');
              return Promise.resolve();
            };
          }
        }

        // Consolidated play event handler with debouncing
        let playEventDebounce = null;
        
        function handlePlayEvent() {
          console.log('🎬 Video play event triggered');
          isPlaying = true;
          console.log('▶️ Video started playing');
          
          // Only check for conflicts when starting a NEW session
          if (!currentSessionId) {
            console.log('🔄 No active session - trying to start one');
            
            // Try to start session
            startWatchSession(playlist[currentIndex], "standard").then(sessionId => {
              if (!sessionId) {
                // Failed to start - desktop app active or rate limited
                console.log('❌ Cannot start session - pausing video');
            player.pause();
            showConflictToast();
            return;
          }
          
              // Session started successfully
              currentSessionId = sessionId;
            sessionStartTime = Date.now();
              currentVideoStartTime = Date.now();
              pausedCount = 0;
              console.log('✅ Session started:', sessionId);
              
              // Start ad tracking
              if (!currentAdTrackingId) {
                console.log('📺 Starting ad tracking for session:', currentSessionId);
            startAdTracking(currentSessionId).then(adTrackingId => {
              if (adTrackingId) {
                currentAdTrackingId = adTrackingId;
                    isAdPlaying = true;  // CRITICAL: Set ad playing flag
                    adStartTime = Date.now();  // CRITICAL: Set ad start time
                    console.log('📺 Ad tracking started with ID:', adTrackingId);
                    console.log('📺 Ad playing flag set to true, start time:', adStartTime);
                  } else {
                    console.log('❌ Failed to start ad tracking - no ID returned');
                  }
                }).catch(error => {
                  console.error('❌ Error starting ad tracking:', error);
                });
          } else {
                console.log('📺 Ad tracking already active:', currentAdTrackingId);
              }
            });
          } else {
            // Session already exists, just update timing
            if (!sessionStartTime) {
              sessionStartTime = Date.now();
            }
            currentVideoStartTime = Date.now();
          }
          
          // Hide the big play button when playing - try multiple times to ensure it works
          const hidePlayButton = () => {
            const bigPlayButton = player.el().querySelector('.vjs-big-play-button');
            if (bigPlayButton) {
              console.log('🎯 Hiding play button');
              bigPlayButton.style.display = 'none';
              bigPlayButton.style.visibility = 'hidden';
              bigPlayButton.style.opacity = '0';
              bigPlayButton.style.pointerEvents = 'none';
            }
          };
          
          // Try immediately and with delays
          hidePlayButton();
          setTimeout(hidePlayButton, 50);
          setTimeout(hidePlayButton, 100);
          setTimeout(hidePlayButton, 200);
          setTimeout(hidePlayButton, 500);
        }

        player.on('pause', () => {
          isPlaying = false;
          pausedCount++;
          console.log('⏸️ Video paused, pause count:', pausedCount);
          
          // No monitoring to stop
          
          // Accumulate actual playback time if ad was playing
          if (isAdPlaying && adStartTime) {
            const currentTime = player.currentTime() || 0;
            accumulatedAdTime = currentTime;
            console.log('📺 Ad tracking paused - Current video time:', Math.floor(currentTime), 'seconds');
          }
          
          // Don't complete ad tracking on pause - just pause the tracking
          // The ad is still playing, just paused
          console.log('📺 Ad tracking paused (not completed)');
          
          // Show the big play button when paused
          const showPlayButton = () => {
            const bigPlayButton = player.el().querySelector('.vjs-big-play-button');
            if (bigPlayButton) {
              console.log('🎯 Showing play button');
              bigPlayButton.style.display = 'flex';
              bigPlayButton.style.visibility = 'visible';
              bigPlayButton.style.opacity = '1';
              bigPlayButton.style.pointerEvents = 'auto';
            }
          };
          
          showPlayButton();
          setTimeout(showPlayButton, 50);
          setTimeout(showPlayButton, 100);
        });

        // Show play button when clicking anywhere on the video while playing
        player.on('click', () => {
          if (isPlaying) {
            const bigPlayButton = player.el().querySelector('.vjs-big-play-button');
            if (bigPlayButton) {
              console.log('🎯 Showing play button on click');
              bigPlayButton.style.display = 'flex';
              bigPlayButton.style.visibility = 'visible';
              bigPlayButton.style.opacity = '1';
              bigPlayButton.style.pointerEvents = 'auto';
            }
          }
        });

        // Video ended event - completes ad tracking and session
        player.on("ended", async function () {
          const now = Date.now();
          if (now - lastEndedEvent < ENDED_EVENT_DEBOUNCE) {
            return; // Skip duplicate ended events
          }
          lastEndedEvent = now;
          
          // No monitoring to stop
          
          console.log(`🎬 Video ${currentIndex + 1} (${playlist[currentIndex]}) ended, switching to next video...`);
          console.log(`🎬 Current player state:`, {
            readyState: player.readyState(),
            paused: player.paused(),
            ended: player.ended(),
            currentSrc: player.currentSrc()
          });
          
          // Complete ad tracking if ad was playing (only when video actually ends)
          console.log('🔍 VIDEO END - TRACKING STATE:', {
            currentSessionId: currentSessionId,
            currentAdTrackingId: currentAdTrackingId, 
            isAdPlaying: isAdPlaying,
            currentVideoStartTime: currentVideoStartTime,
            playerCurrentTime: player.currentTime(),
            sessionStartTime: sessionStartTime,
            adStartTime: adStartTime,
            accumulatedAdTime: accumulatedAdTime
          });
          
          // CRITICAL FIX: Always try to complete ad tracking if we have an ID
          if (currentAdTrackingId) {
            console.log('📺 CALLING completeAdTracking - has tracking ID:', currentAdTrackingId);
            console.log('📺 Video info:', {
              currentVideo: playlist[currentIndex],
              videoIndex: currentIndex + 1,
              totalVideos: playlist.length
            });
            
            // Use the video's current time for accurate tracking (excludes loading/buffering time)
            const currentTime = player.currentTime() || 0;
            const adDurationSeconds = Math.floor(Math.max(currentTime, accumulatedAdTime));
            console.log('🔍 Ad duration calculation:', {
              currentTime: currentTime,
              accumulatedAdTime: accumulatedAdTime,
              finalDuration: adDurationSeconds,
              videoDuration: player.duration()
            });
            
            // Store the tracking ID before resetting to prevent reuse
            const trackingIdToComplete = currentAdTrackingId;
            
            // CRITICAL: Reset ad tracking state BEFORE completion to prevent reuse
            isAdPlaying = false;
            currentAdTrackingId = null;  // Reset immediately to prevent reuse
            adStartTime = null;
            accumulatedAdTime = 0;
            
            console.log('📺 Completing ad tracking with ID:', trackingIdToComplete);
            await completeAdTracking(trackingIdToComplete, adDurationSeconds, true);
            
            console.log('📺 Ad tracking completed on video end:', adDurationSeconds, 'seconds (actual video time)');
          } else {
            console.log('❌ No ad tracking ID available - skipping completion');
          }
          
          // Complete current session if exists
          if (!isQualitySwitching && currentSessionId && currentVideoStartTime) {
            const durationSeconds = Math.floor((Date.now() - currentVideoStartTime) / 1000);
            console.log('📺 Completing session:', {
              sessionId: currentSessionId,
              durationSeconds: durationSeconds,
              pausedCount: pausedCount,
              videoName: playlist[currentIndex]
            });
            
            if (typeof completeWatchSession === 'function') {
              await completeWatchSession(currentSessionId, durationSeconds, true, pausedCount);
            } else {
              console.error('❌ completeWatchSession function not available!');
            }
            
            currentVideoStartTime = null;
            sessionStartTime = null;
            pausedCount = 0;
            currentSessionId = null;
          } else {
            console.log('📺 Skipping session completion:', {
              isQualitySwitching: isQualitySwitching,
              hasSessionId: !!currentSessionId,
              hasStartTime: !!currentVideoStartTime
            });
          }
          
          if (!isQualitySwitching) {
            // Move to next video in playlist
            const oldIndex = currentIndex;
            currentIndex = (currentIndex + 1) % playlist.length;
            console.log(`🔄 Switching from video ${oldIndex + 1} (${playlist[oldIndex]}) to video ${currentIndex + 1} (${playlist[currentIndex]})`);
            console.log(`🔄 Next video URL: videos/${playlist[currentIndex]}.mp4`);
            
            // Track video completion for popup ads
            if (popupAdManager && typeof popupAdManager.onVideoEnded === 'function') {
              popupAdManager.onVideoEnded();
            }
            
            // Load the next video using the same method as initial load
            loadVideoWithQuality(currentIndex);
            
            // No automatic session start - wait for user to click play to start session
            console.log('📺 Video loaded - waiting for user to click play to start session');
          } else {
            console.log('⚠️ Quality switching in progress, skipping video switch');
          }
        });

        player.on("waiting", () => {
          if (!isQualitySwitching) {
            loadingIndicator.style.display = "block";
          }
        });

        player.on("playing", () => {
          loadingIndicator.style.display = "none";
        });

        player.on("error", function() {
          const error = player.error();
          console.error('Video error:', error);
          console.error('Current video should be:', getCurrentVideoSource().src);
          loadingIndicator.style.display = "none";
        });

        // Set up event handlers immediately after player creation
        console.log('=== AUTHENTICATED VIDEO PLAYER LOADED ===');
        disableDoubleClickFullscreen();
        
        // Set up play button behavior
        const bigPlayButton = player.el().querySelector('.vjs-big-play-button');
        if (bigPlayButton) {
          bigPlayButton.addEventListener('click', async function(e) {
            e.preventDefault();
            e.stopPropagation();
            
            console.log('🎯 Play button clicked - checking for conflicts...');
            
            // No conflict checking - server will handle this when session starts
            
            console.log('✅ No conflicts - starting video');
            
            // Mark that user has manually started playback (for new users)
            localStorage.setItem('charityStream_userStartedPlayback', 'true');
            
            // Ensure smooth playback
            setTimeout(() => {
              player.play().catch(error => {
                console.log('Play button click prevented:', error);
              });
            }, 10);
          });
        }

        // Hide unwanted controls
        const progress = player.controlBar.progressControl;
        if (progress) progress.el().style.display = "none";
        const fullscreenBtn = player.controlBar.fullscreenToggle;
        if (fullscreenBtn) fullscreenBtn.el().style.display = "none";
        const pipBtn = player.controlBar.pictureInPictureToggle;
        if (pipBtn) pipBtn.el().style.display = "none";
        
        // Hide time displays
        const currentTimeDisplay = player.controlBar.currentTimeDisplay;
        if (currentTimeDisplay) currentTimeDisplay.el().style.display = "none";
        const durationDisplay = player.controlBar.durationDisplay;
        if (durationDisplay) durationDisplay.el().style.display = "none";
        const remainingTimeDisplay = player.controlBar.remainingTimeDisplay;
        if (remainingTimeDisplay) remainingTimeDisplay.el().style.display = "none";
        const timeDivider = player.controlBar.timeDivider;
        if (timeDivider) timeDivider.el().style.display = "none";

        // Add error handling for video loading
        player.on('loadstart', function() {
          console.log('Video loading started');
        });

        player.on('loadedmetadata', function() {
          console.log('Video metadata loaded');
        });

        player.on('loadeddata', function() {
          console.log('Video data loaded');
        });

        // Set up all event handlers immediately
        player.on("waiting", () => {
          if (!isQualitySwitching) {
            loadingIndicator.style.display = "block";
          }
        });

        player.on("playing", () => {
          loadingIndicator.style.display = "none";
        });

        player.on("error", function() {
          const error = player.error();
          console.error('Video error:', error);
          console.error('Current video should be:', getCurrentVideoSource().src);
          loadingIndicator.style.display = "none";
        });

        player.on('play', () => {
          // Debounce play events to prevent rapid firing
          if (playEventDebounce) {
            clearTimeout(playEventDebounce);
          }
          playEventDebounce = setTimeout(handlePlayEvent, 500);
        });

        player.on('pause', () => {
          isPlaying = false;
          console.log('⏸️ Video paused');
          
          // No monitoring to stop
          
          // Show the big play button when paused
          const bigPlayButton = player.el().querySelector('.vjs-big-play-button');
          if (bigPlayButton) {
            console.log('🎯 Showing play button on pause');
            bigPlayButton.style.display = 'flex';
            bigPlayButton.style.visibility = 'visible';
            bigPlayButton.style.opacity = '1';
            bigPlayButton.style.pointerEvents = 'auto';
          }
        });

        // Show play button when clicking anywhere on the video while playing
        player.on('click', () => {
          if (isPlaying) {
            const bigPlayButton = player.el().querySelector('.vjs-big-play-button');
            if (bigPlayButton) {
              console.log('🎯 Showing play button on click');
              bigPlayButton.style.display = 'flex';
              bigPlayButton.style.visibility = 'visible';
              bigPlayButton.style.opacity = '1';
              bigPlayButton.style.pointerEvents = 'auto';
            }
          }
        });

        // Initialize playlist from backend, then load first video
        console.log('Video player ready, loading playlist...');
        isPlayerInitialized = true;
        
        // Wait for playlist to load before starting video
        initializePlaylist().then(() => {
          if (playlist.length > 0) {
            console.log('✅ Playlist loaded, starting first video');
        loadVideoWithQuality(0);
          } else {
            console.error('❌ Playlist is empty, cannot load video');
          }
        }).catch(error => {
          console.error('❌ Failed to initialize playlist:', error);
        });
        
        // Ensure play button is visible initially
        if (bigPlayButton) {
          bigPlayButton.style.display = 'flex';
        }

        console.log('Authenticated video player initialization complete!');
        
        // No initial monitoring needed - server handles conflicts
        
      } catch (error) {
        console.error('Error initializing authenticated video player:', error);
      }
    }

    // Viewport framing script
    (function() {
      if (!window.matchMedia || !window.matchMedia('(min-width:1024px)').matches) return;
      var scaler = document.getElementById('framed-viewport');
      if (!scaler) return;
      var inner = scaler.querySelector('.frame-inner');
      if (!inner) return;

      function fit() {
        // Reset, measure, then scale down if needed
        inner.style.transform = 'scale(1)';
        var H = inner.getBoundingClientRect().height;
        var vh = window.innerHeight;
        var s = Math.min(1, vh / H);
        inner.style.transform = 'scale(' + s + ')';
        scaler.style.height = (H * s) + 'px';
      }

      window.addEventListener('load', fit, { once: true });
      window.addEventListener('resize', fit);
      // In case fonts/assets shift layout slightly after load
      setTimeout(fit, 600);
    })();

    // Pop-up Ad System
    class PopupAdManager {
      constructor() {
        this.videoPlayer = null;
        this.isActive = false; // Track if pop-ups should be active
        this.videoCount = 0; // Track number of videos played
        this.popupInterval = 2; // Show popup every 2-3 videos
        this.currentPopup = null; // Only one popup at a time
        this.shouldShowPopupAfterTransition = false; // Flag to show popup after video transition
        this.pauseCheckInterval = null; // Interval to check if video stays paused
        
        this.init();
      }

      init() {
        // Set up navigation cleanup
        window.addEventListener('beforeunload', () => {
          this.cleanup();
        });

        // Don't start scheduling pop-ups immediately - wait for authentication check
        console.log('📢 Pop-up ad manager initialized (waiting for authentication)');
      }

      // Method to activate pop-ups (called only for authenticated users)
      activate() {
        if (this.isActive) return;
        
        this.isActive = true;
        console.log('📢 Pop-up ads activated for authenticated user');
      }

      // Method to deactivate pop-ups (called when user logs out)
      deactivate() {
        this.isActive = false;
        this.cleanup();
        console.log('📢 Pop-up ads deactivated');
      }

      setVideoPlayer(player) {
        console.log('📢 Setting video player reference:', !!player);
        this.videoPlayer = player;
        console.log('📢 Video player reference set successfully');
      }

      // Method to track video completion and show popup every 2-3 videos
      onVideoEnded() {
        console.log('📢 onVideoEnded called, isActive:', this.isActive);
        if (!this.isActive) {
          console.log('📢 Popup ads not active, skipping video count');
          return;
        }
        
        this.videoCount++;
        console.log(`📢 Video count: ${this.videoCount}, popup interval: ${this.popupInterval}`);
        
        // Show popup every 2-3 videos (random interval)
        if (this.videoCount >= this.popupInterval) {
          console.log('📢 Time to show popup! Scheduling popup for after video transition...');
          // Don't show popup immediately - wait for next video to load and start playing
          this.shouldShowPopupAfterTransition = true;
          // Reset count and set next interval (2-3 videos)
          this.videoCount = 0;
          this.popupInterval = Math.floor(Math.random() * 2) + 2; // 2 or 3
          console.log(`📢 Next popup will show after ${this.popupInterval} videos`);
        } else {
          console.log(`📢 Need ${this.popupInterval - this.videoCount} more videos before popup`);
        }
      }

      // Method to check if popup should be shown after video starts playing
      onVideoStartedPlaying() {
        if (this.shouldShowPopupAfterTransition) {
          console.log('📢 Video started playing, showing scheduled popup...');
          this.shouldShowPopupAfterTransition = false;
          // Wait a moment for video to be fully playing, then show popup
          setTimeout(() => {
            this.showPopup();
          }, 2000); // Wait 2 seconds for video to be playing smoothly
        }
      }

      showPopup() {
        // Only show one popup at a time
        if (this.currentPopup) {
          console.log('📢 Popup already active, skipping');
          return;
        }

        // Check if video player exists - try multiple ways to get the player
        let videoPlayer = this.videoPlayer;
        if (!videoPlayer && typeof player !== 'undefined' && player) {
          console.log('📢 Using global player reference as fallback');
          videoPlayer = player;
        }
        
        if (!videoPlayer) {
          console.log('📢 No video player available, skipping popup');
          return;
        }

        console.log('📢 Video player found:', !!videoPlayer, 'Ready state:', videoPlayer.readyState ? videoPlayer.readyState() : 'N/A');

        // Create new popup
        const popup = this.createPopup();
        this.currentPopup = popup;
        
        console.log('📢 Showing pop-up ad');
        
        // Position pop-up randomly but ensure it's fully visible
        this.positionPopup(popup.element);
        
        // Show pop-up
        popup.element.classList.add('show');
        
        // Pause video immediately when popup appears
        setTimeout(() => {
          if (videoPlayer && !videoPlayer.paused()) {
            console.log('📢 Attempting to pause video for popup...');
            try {
              videoPlayer.pause();
            } catch (error) {
              console.log('Video pause prevented:', error);
            }
            console.log('📢 Video paused due to popup');
          } else if (videoPlayer && videoPlayer.paused()) {
            console.log('📢 Video already paused when popup appeared');
          } else {
            console.log('📢 No video player available for popup pause');
          }
        }, 100); // Increased delay to ensure video player is ready
        
        // Also set up a periodic check to ensure video stays paused while popup is active
        this.pauseCheckInterval = setInterval(() => {
          if (this.currentPopup && videoPlayer && !videoPlayer.paused()) {
            console.log('📢 Video started playing while popup active, pausing again...');
            videoPlayer.pause().catch(error => {
              console.log('Video pause prevented:', error);
            });
          }
        }, 500); // Check every 500ms
      }

      createPopup() {
        // Create popup element
        const popupElement = document.createElement('div');
        popupElement.className = 'popup-ad';
        
        // Create close button
        const closeBtn = document.createElement('button');
        closeBtn.className = 'popup-close-btn';
        closeBtn.innerHTML = '×';
        closeBtn.addEventListener('click', () => {
          this.closePopup();
        });
        
        // Create content
        const content = document.createElement('div');
        content.className = 'popup-content';
        content.textContent = 'pop up';
        
        popupElement.appendChild(closeBtn);
        popupElement.appendChild(content);
        
        // Add to page
        document.body.appendChild(popupElement);
        
        // Return popup object
        return {
          element: popupElement
        };
      }

      positionPopup(popupElement) {
        const viewportWidth = window.innerWidth;
        const viewportHeight = window.innerHeight;
        const popupWidth = 384;
        const popupHeight = 384;

        // Calculate random position ensuring popup stays within viewport
        const maxX = Math.max(0, viewportWidth - popupWidth);
        const maxY = Math.max(0, viewportHeight - popupHeight);

        const randomX = Math.random() * maxX;
        const randomY = Math.random() * maxY;

        popupElement.style.left = `${randomX}px`;
        popupElement.style.top = `${randomY}px`;
      }

      closePopup() {
        if (!this.currentPopup) return;

        console.log('📢 Closing pop-up ad');
        
        // Clear the pause check interval
        if (this.pauseCheckInterval) {
          clearInterval(this.pauseCheckInterval);
          this.pauseCheckInterval = null;
          console.log('📢 Cleared pause check interval');
        }
        
        // Remove from DOM
        this.currentPopup.element.remove();
        
        // Clear current popup reference
        this.currentPopup = null;

        // Resume video when popup is closed - try multiple ways to get the player
        setTimeout(() => {
          let videoPlayer = this.videoPlayer;
          if (!videoPlayer && typeof player !== 'undefined' && player) {
            console.log('📢 Using global player reference as fallback for resume');
            videoPlayer = player;
          }
          
          if (videoPlayer && videoPlayer.paused()) {
            console.log('📢 Attempting to resume video after popup close...');
            videoPlayer.play().catch(error => {
              console.log('Video resume prevented:', error);
            });
            console.log('📢 Video resumed after popup close');
          } else if (videoPlayer && !videoPlayer.paused()) {
            console.log('📢 Video already playing when popup closed');
          } else {
            console.log('📢 No video player available for popup resume');
          }
        }, 100); // Increased delay to ensure video player is ready
      }

      cleanup() {
        console.log('📢 Cleaning up pop-up ad system');
        
        // Clear pause check interval
        if (this.pauseCheckInterval) {
          clearInterval(this.pauseCheckInterval);
          this.pauseCheckInterval = null;
        }
        
        // Close current popup if exists
        if (this.currentPopup) {
          this.currentPopup.element.remove();
          this.currentPopup = null;
        }
      }

      // Public method to pause pop-ups (useful for debugging)
      pausePopups() {
        console.log('📢 Pop-up ads paused');
        this.isActive = false;
      }

      // Public method to resume pop-ups (useful for debugging)
      resumePopups() {
        console.log('📢 Pop-up ads resumed');
        this.isActive = true;
      }

    }

    // Initialize pop-up ad manager
    const popupAdManager = new PopupAdManager();

    // Set up video player reference when it's initialized (only for authenticated users)
    let originalInitializeVideoPlayer = null;
    let originalInitializeVideoPlayerForGuests = null;

    // Override the video player initialization to set up pop-up ad manager
    function setupPopupAdWithPlayer() {
      // Only set up pop-up ads for authenticated users
      if (!authToken) {
        console.log('📢 Pop-up ads disabled - user not authenticated');
        popupAdManager.deactivate();
        return;
      }
      
      // Check if tutorial is active
      if (window.isTutorialActive) {
        console.log('⏸ Popup ads blocked until tutorial dismissed');
        return;
      }
      
      // Try to get the video player reference
      let videoPlayer = player;
      if (!videoPlayer && typeof window.player !== 'undefined') {
        videoPlayer = window.player;
      }
      
      if (videoPlayer && !popupAdManager.videoPlayer) {
        console.log('📢 Setting up popup ad manager with video player:', !!videoPlayer);
        console.log('📢 Video player ready state:', videoPlayer.readyState ? videoPlayer.readyState() : 'N/A');
        popupAdManager.setVideoPlayer(videoPlayer);
        popupAdManager.activate(); // Activate pop-ups for authenticated users
        
        // Add event listener for when video starts playing to check for scheduled popups
        videoPlayer.on("playing", () => {
          if (popupAdManager && typeof popupAdManager.onVideoStartedPlaying === 'function') {
            popupAdManager.onVideoStartedPlaying();
          }
        });
        
        console.log('📢 Pop-up ad manager connected to video player and activated');
      } else if (videoPlayer && popupAdManager.videoPlayer) {
        console.log('📢 Popup ad manager already has video player reference');
      } else {
        console.log('📢 No video player available for popup setup, will retry...');
        // Retry after a delay
        setTimeout(() => {
          setupPopupAdWithPlayer();
        }, 2000);
      }
    }

    // Hook into existing video player initialization
    const originalPlayerInit = initializeVideoPlayer;
    initializeVideoPlayer = function() {
      const result = originalPlayerInit.apply(this, arguments);
      
      // Set up pop-up ad manager after player is ready (only for authenticated users and not during tutorial)
      if (authToken && !window.isTutorialActive) {
        setTimeout(() => {
          setupPopupAdWithPlayer();
        }, 1000);
      } else if (window.isTutorialActive) {
        console.log('🎓 Tutorial active - pop-up ads delayed until tutorial completes');
      }
      
      return result;
    };

    // Also hook into guest player initialization
    const originalGuestPlayerInit = initializeVideoPlayerForGuests;
    initializeVideoPlayerForGuests = function() {
      const result = originalGuestPlayerInit.apply(this, arguments);
      
      // Ensure pop-up ads are deactivated for guest users
      popupAdManager.deactivate();
      
      return result;
    };

    // Make popupAdManager globally available for debugging
    window.popupAdManager = popupAdManager;
    
    // Add manual test functions for debugging
    window.testPopup = function() {
      console.log('🧪 Manual popup test triggered');
      if (popupAdManager) {
        popupAdManager.showPopup();
      } else {
        console.log('❌ PopupAdManager not available');
      }
    };
    
    window.testPopupPause = function() {
      console.log('🧪 Manual pause test triggered');
      if (player && !player.paused()) {
        player.pause().catch(error => {
          console.log('Pause test failed:', error);
        });
        console.log('✅ Video paused manually');
      } else {
        console.log('❌ No player or already paused');
      }
    };
    
    window.testPopupResume = function() {
      console.log('🧪 Manual resume test triggered');
      if (player && player.paused()) {
        player.play().catch(error => {
          console.log('Resume test failed:', error);
        });
        console.log('✅ Video resumed manually');
      } else {
        console.log('❌ No player or already playing');
      }
    };

    // Tutorial System - PNG-based
    class TutorialManager {
      constructor() {
        this.currentStep = 0;
        this.isActive = false;
        
        // Tutorial now handled by separate tutorial.html page

        // bind methods if needed
        this.onAuthReady = this.onAuthReady.bind(this);

        // init basic listeners (buttons etc)
        this.initUIListeners();

        // Do not call checkTutorialModal() synchronously here.
        // Instead, either:
        //  - If auth is already known, run the check now, or
        //  - Otherwise wait for the global authReady event.
        if (typeof authToken !== 'undefined' && authToken) {
          // authToken already exists -> safe to evaluate
          this.checkTutorialModal();
        } else {
          // wait for auth to be known (fires once)
          window.addEventListener('authReady', this.onAuthReady, { once: true });
          // also run a fallback check after a small timeout in case authReady never fires
          // (defensive), but only if newUser flag is present.
          const isNewUserFlag = localStorage.getItem('charityStream_newUser') === 'true';
          if (isNewUserFlag) {
            // show modal after short delay even if auth isn't known (useful for signup flows
            // where newUser is set via URL params and no auth token exists yet)
            setTimeout(() => this.checkTutorialModal(), 1000);
          }
        }
      }

      initUIListeners() {
        // Attach click handlers for modal buttons (safe even if DOM wasn't ready earlier)
        const yesBtn = document.getElementById('tutorialYes');
        const noBtn = document.getElementById('tutorialNo');

        if (yesBtn) {
          yesBtn.addEventListener('click', () => {
            this.hideModal();
            // Redirect to the dedicated tutorial page
            window.location.href = '/tutorial.html';
          });
        }

        if (noBtn) {
          noBtn.addEventListener('click', () => {
            this.hideModal();
            this.markTutorialSeen();
          });
        }

        document.getElementById('tutorialCompleteBtn').addEventListener('click', () => {
          this.hideComplete();
        });
      }

      onAuthReady() {
        // authReady fired -> now an authToken variable should be populated or confirmed absent
        this.checkTutorialModal();
      }

      checkTutorialModal() {
        const hasSeenTutorial = localStorage.getItem('charityStream_tutorialSeen') === 'true';
        const isNewUser = localStorage.getItem('charityStream_newUser') === 'true';

        // If user has already seen tutorial -> nothing to do
        if (hasSeenTutorial) return;

        // If new user flagged, show modal. If not flagged but authToken exists and not seen,
        // set newUser flag and show modal.
        if (isNewUser) {
          // show modal after short delay so UI has time to settle
          setTimeout(() => this.showModal(), 700);
          return;
        }

        // If authToken exists and the user hasn't seen the tutorial, treat them as new user
        if (typeof authToken !== 'undefined' && authToken && !hasSeenTutorial) {
          localStorage.setItem('charityStream_newUser', 'true');
          console.log('🎓 Authenticated user detected - setting new user flag for tutorial');
          setTimeout(() => this.showModal(), 700);
          return;
        }

        // If neither newUser flag nor auth known yet, we already attached authReady listener in constructor.
        // Nothing else to do here.
      }

      showModal() {
        const modal = document.getElementById('tutorialModal');
        if (!modal) return;
        modal.style.display = 'block';
        this.isActive = true;
        window.isTutorialActive = true; // expose for other parts of the app if they check it
        console.log('🎓 Tutorial modal shown - video/popups paused');

        // Pause videos/popups immediately when modal shows
        if (typeof pauseVideosAndPopups === 'function') pauseVideosAndPopups();
      }

      hideModal() {
        const modal = document.getElementById('tutorialModal');
        if (!modal) return;
        modal.style.display = 'none';
        this.isActive = false;
        window.isTutorialActive = false;
        console.log('🎓 Tutorial modal hidden - popups can resume, video stays paused until user clicks play');

        // Resume popup ads only (video stays paused until user manually starts it)
        if (typeof resumePopupsAfterTutorial === 'function') {
          resumePopupsAfterTutorial();
        } else if (window.popupAdManager && typeof window.popupAdManager.activate === 'function') {
          console.log('📢 Resuming popup ads after tutorial dismissal');
          window.popupAdManager.activate();
        }

        // For new users, clear the tutorial flag so video transitions work normally
        // but don't start the current video - it stays paused until user clicks play
        const isNewUser = localStorage.getItem('charityStream_newUser') === 'true';
        if (isNewUser) {
          console.log('🎓 New user tutorial dismissed - video transitions enabled, current video stays paused');
        }
      }

      hideComplete() {
        document.getElementById('tutorialComplete').style.display = 'none';
      }

      // Called when user completes the tutorial or explicitly dismisses it
      markTutorialSeen() {
        localStorage.setItem('charityStream_tutorialSeen', 'true');
        localStorage.removeItem('charityStream_newUser');
      }

      // Tutorial now handled by separate tutorial.html page

      // Tutorial completion is now handled by tutorial.html page

      showComplete() {
        document.getElementById('tutorialComplete').style.display = 'block';
      }

      // Public method to reset tutorial (for testing)
      resetTutorial() {
        localStorage.removeItem('charityStream_tutorialSeen');
        localStorage.setItem('charityStream_newUser', 'true');
        console.log('Tutorial reset - will show on next page load');
      }
    }

    // Initialize tutorial manager
    const tutorialManager = new TutorialManager();

    // Make tutorial manager globally available for debugging
    window.tutorialManager = tutorialManager;

    // Global flag to track if tutorial is active
    let isTutorialActive = false;
    window.isTutorialActive = false; // Initialize global flag

    // Video playback is now only user-initiated - no automatic resumption

    // Function to resume pop-up ads after tutorial completion
    function resumePopupsAfterTutorial() {
      if (authToken && popupAdManager && !popupAdManager.isActive) {
        console.log('🎓 Tutorial completed - resuming pop-up ads');
        setTimeout(() => {
          setupPopupAdWithPlayer();
        }, 1000);
      }
    }

    // Check for new user status from URL parameters or other sources
    function checkNewUserStatus() {
      const urlParams = new URLSearchParams(window.location.search);
      const isNewUser = urlParams.get('newUser') === 'true' || 
                       urlParams.get('tutorial') === 'true' ||
                       urlParams.get('signup') === 'true' ||
                       urlParams.get('registered') === 'true' ||
                       localStorage.getItem('charityStream_newUser') === 'true';
      
      if (isNewUser) {
        localStorage.setItem('charityStream_newUser', 'true');
        window.isTutorialActive = true; // Block video auto-play for new users
        console.log('🎓 New user detected - tutorial will be offered, video auto-play blocked');
      }
    }

    // Run new user check on page load
    checkNewUserStatus();

    // Add premium status check and UI updates
    let isPremiumUser = false;

    // Check premium status on page load
    async function checkPremiumStatus() {
        const authToken = localStorage.getItem('authToken');
        if (!authToken) return;

        try {
            const response = await fetch('/api/auth/me', {
                headers: {
                    'Authorization': `Bearer ${authToken}`
                }
            });

            if (response.ok) {
                const data = await response.json();
                isPremiumUser = data.user.isPremium || false;
                console.log('👑 Premium status:', isPremiumUser);
                
                if (isPremiumUser) {
                    enablePremiumUI();
                }
            }
        } catch (error) {
            console.error('❌ Error checking premium status:', error);
        }
    }

    // Enable premium UI features
    function enablePremiumUI() {
        console.log('🎉 Enabling premium features');
        
        // Premium users get enhanced features (pop-out, no ads, etc.)
        // Quality is already HD for all users
        
        // Update quality display if element exists
        const qualityDisplay = document.getElementById('currentQualityDisplay');
        if (qualityDisplay) {
            qualityDisplay.textContent = "Premium HD";
        }
        
        // Add pop-out button
        const videoControls = document.querySelector('.video-controls');
        if (videoControls && !document.getElementById('popoutBtn')) {
            const popoutBtn = document.createElement('button');
            popoutBtn.id = 'popoutBtn';
            popoutBtn.className = 'popout-btn';
            popoutBtn.textContent = 'Pop Out';
            popoutBtn.onclick = requestPictureInPicture;
            videoControls.appendChild(popoutBtn);
        }
        
        // Update upgrade button text
        const upgradeBtn = document.querySelector('.upgrade-btn');
        if (upgradeBtn) {
            upgradeBtn.textContent = 'Premium Active';
            upgradeBtn.style.backgroundColor = '#10b981';
            upgradeBtn.onclick = null;
        }
    }

    // Picture-in-Picture function
    async function requestPictureInPicture() {
        try {
            if (player && player.el()) {
                await player.el().requestPictureInPicture();
                console.log('✅ Picture-in-Picture activated');
            }
        } catch (error) {
            console.error('❌ Picture-in-Picture failed:', error);
            showMessage('Picture-in-Picture not supported or failed', 'error');
        }
    }

    // Manual debugging commands - available in browser console
    window.debugAPI = {
      // Show current stats
      stats() {
        console.log('Current stats:', frontendRequestTracker.getStats());
        frontendRequestTracker.printSummary();
      },
      
      // Show all requests
      allRequests() {
        console.table(frontendRequestTracker.requests.map(r => ({
          time: r.timeString,
          endpoint: r.endpoint,
          status: r.status,
          duration: `${r.duration}ms`
        })));
      },
      
      // Show only errors
      errors() {
        const errors = frontendRequestTracker.requests.filter(r => r.status >= 400);
        console.table(errors.map(r => ({
          time: r.timeString,
          endpoint: r.endpoint,
          status: r.status,
          caller: r.stackTrace[0]
        })));
      },
      
      // Show 429 errors specifically
      rateLimitErrors() {
        const errors = frontendRequestTracker.requests.filter(r => r.status === 429);
        console.log(`Total 429 errors: ${errors.length}`);
        console.table(errors.map(r => ({
          time: r.timeString,
          endpoint: r.endpoint,
          caller: r.stackTrace[0]
        })));
      },
      
      // Clear tracking data
      clear() {
        frontendRequestTracker.requests = [];
        frontendRequestTracker.startTime = Date.now();
        console.log('✅ Request tracking data cleared');
      },
      
      // Check subscription status
      async checkSubscription() {
        console.log('🔍 Manual subscription status check...');
        const authToken = localStorage.getItem('authToken');
        
        if (!authToken) {
          console.log('❌ No auth token found');
          return;
        }
        
        try {
          const response = await trackedFetch('/api/user/me', {
            headers: {
              'Authorization': `Bearer ${authToken}`
            }
          });
          
          if (response.ok) {
            const userData = await response.json();
            console.log('👤 Current user data:', userData);
            console.log('💎 Is premium:', userData.user.isPremium);
            console.log('🎫 Subscription tier:', userData.user.subscriptionTier);
            console.log('📧 Email:', userData.user.email);
          }
        } catch (error) {
          console.error('❌ Error checking subscription status:', error);
        }
      }
    };

    console.log('🔍 Debug commands available:');
    console.log('  window.debugAPI.stats() - Show request statistics');
    console.log('  window.debugAPI.allRequests() - Show all requests');
    console.log('  window.debugAPI.errors() - Show all errors');
    console.log('  window.debugAPI.rateLimitErrors() - Show 429 errors');
    console.log('  window.debugAPI.clear() - Clear tracking data');
    console.log('  window.debugAPI.checkSubscription() - Check subscription status');

    // Update the page load event
    document.addEventListener('DOMContentLoaded', function() {
        // ... existing code ...
        // Don't automatically check premium status - only check when user interacts
        console.log('🎬 Page loaded - premium status will be checked on user interaction');
    });
  </script>
</body>
</html>